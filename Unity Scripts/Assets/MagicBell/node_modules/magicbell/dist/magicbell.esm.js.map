{"version":3,"file":"magicbell.esm.js","sources":["../src/lib/crypto.ts","../src/lib/env.ts","../src/lib/error.ts","../src/lib/headers.ts","../src/lib/log.ts","../src/lib/utils.ts","../src/paginate.ts","../src/listen.ts","../src/options.ts","../src/method.ts","../src/resource.ts","../src/resources/imports.ts","../src/resources/notification-preferences.ts","../src/resources/notifications.ts","../src/resources/push-subscriptions.ts","../src/resources/subscriptions.ts","../src/resources/users.ts","../src/client.ts"],"sourcesContent":["import crypto from 'crypto';\n\nexport function createHmac(secret: string, data: string) {\n  if (!secret || !data) return '';\n\n  if (!crypto || !crypto.createHmac) {\n    throw new Error('This method is not available in the browser. Please provide a userHmac.');\n  }\n\n  return crypto.createHmac('sha256', secret).update(data).digest('base64');\n}\n","import { ClientOptions } from '../types';\n\nexport function getEnvInfo() {\n  const common = {\n    binding: __PACKAGE_NAME__,\n    binding_version: __PACKAGE_VERSION__,\n    publisher: 'magicbell',\n  };\n\n  if (typeof process === 'undefined') {\n    return common;\n  }\n\n  return {\n    ...common,\n    runtime: process?.release?.name || 'node',\n    runtime_version: process.version,\n    platform: process.platform,\n    arch: process.arch,\n  };\n}\n\nfunction getAppInfoAsString(appInfo?: ClientOptions['appInfo']) {\n  if (!appInfo?.name) return '';\n\n  return [appInfo?.name, appInfo.version && `/${appInfo.version}`, appInfo.url && ` (${appInfo.url})`]\n    .filter(Boolean)\n    .join('');\n}\n\nexport function getUserAgent(appInfo?: ClientOptions['appInfo']) {\n  const env = getEnvInfo();\n\n  return [\n    `${env.binding}/${env.binding_version}`,\n    'runtime' in env && `${env.runtime}/${env.runtime_version}`,\n    getAppInfoAsString(appInfo),\n  ]\n    .filter(Boolean)\n    .join(' ');\n}\n\nexport function getClientUserAgent(appInfo?: ClientOptions['appInfo']) {\n  return JSON.stringify({ ...getEnvInfo(), application: appInfo });\n}\n","'use strict';\n\n// TODO: sync & cleanup\nexport function createError(rawError: ErrorConfig) {\n  for (const field of ['code', 'type', 'status']) {\n    switch (rawError[field]) {\n      case 'user_identifier_not_provided':\n        return new AuthenticationError(rawError);\n      case 'invalid_request_error':\n        return new InvalidRequestError(rawError);\n      case 'api_error':\n        return new APIError(rawError);\n      case 'authentication_error':\n        return new AuthenticationError(rawError);\n      case 'rate_limit_error':\n        return new RateLimitError(rawError);\n      case 'idempotency_error':\n        return new IdempotencyError(rawError);\n      case 404:\n        return new NotFoundError(rawError);\n      case 422:\n        return new UserInputError(rawError);\n    }\n  }\n\n  return new UnknownError(rawError);\n}\n\ntype ErrorConfig = {\n  name: string;\n  type?: string;\n  code?: string;\n  docs_url?: string;\n  help_link?: string;\n  status?: number;\n  statusText?: string;\n  message: string;\n  suggestion?: string;\n};\n\n/**\n * BaseError is the base error from which all other more specific errors derive.\n * Specifically for errors returned from REST API.\n */\nclass BaseError extends Error {\n  name: string;\n  message: string;\n  type?: string;\n  docs_url?: string;\n  code?: string;\n  status?: number;\n  statusText?: string;\n  suggestion?: string;\n\n  constructor(raw: ErrorConfig) {\n    super(raw.message);\n    this.type = this.constructor.name;\n    this.name = 'MagicBellError';\n    this.code = raw.code;\n    this.status = raw.status;\n    this.statusText = raw.statusText;\n    this.message = raw.message;\n    this.suggestion = raw.suggestion;\n    this.docs_url = raw.docs_url || raw.help_link;\n  }\n}\n\nexport class InvalidRequestError extends BaseError {}\nexport class UserInputError extends BaseError {}\nexport class APIError extends BaseError {}\nexport class AuthenticationError extends BaseError {}\nexport class PermissionError extends BaseError {}\nexport class RateLimitError extends BaseError {}\nexport class ConnectionError extends BaseError {}\nexport class IdempotencyError extends BaseError {}\nexport class UnknownError extends BaseError {}\nexport class NotFoundError extends BaseError {}\n","/**\n * Normalize standard HTTP Headers:\n * {'foo-bar': 'hi'}\n * becomes\n * {'Foo-Bar': 'hi'}\n */\nexport function normalizeHeaders(headers: Record<string, string>) {\n  if (!headers || typeof headers !== 'object') {\n    return headers;\n  }\n\n  const normalized = {};\n  for (const header of Object.keys(headers)) {\n    normalized[normalizeHeader(header)] = headers[header];\n  }\n\n  return normalized;\n}\n\n/**\n * Stolen from https://github.com/marten-de-vries/header-case-normalizer/blob/master/index.js#L36-L41\n * without the exceptions which are irrelevant to us.\n */\nfunction normalizeHeader(header) {\n  const exceptions = {\n    etag: 'ETag',\n    magicbell: 'MagicBell',\n  };\n\n  return header\n    .split('-')\n    .map((text) => exceptions[text.toLowerCase()] || text.charAt(0).toUpperCase() + text.slice(1).toLowerCase())\n    .join('-');\n}\n","import { AxiosRequestConfig } from 'axios';\n\nconst colors = {\n  reset: '\\x1b[0m',\n  magenta: '\\x1b[35m',\n  red: '\\x1b[31m',\n};\n\nexport function emitWarning(message) {\n  if (typeof process.emitWarning !== 'function') {\n    return console.warn(`magicbell: ${message}`);\n  }\n\n  return process.emitWarning(message, 'magicbell');\n}\n\nexport class Logger {\n  active = false;\n\n  debug(message) {\n    if (!this.active) return;\n\n    // eslint-disable-next-line no-console\n    console.log(`${colors.reset}${colors.magenta}magicbell:${colors.reset} ${message}`);\n  }\n\n  error(message) {\n    if (!this.active) return;\n\n    // eslint-disable-next-line no-console\n    console.error(`${colors.reset}${colors.red}magicbell:${colors.reset} ${message}`);\n  }\n}\n\nfunction mask(str: string) {\n  if (__DEV__) return str;\n  return `${str.slice(0, 4)}â€¦${str.slice(-4)}`;\n}\n\nconst secrets = /secret|token|key|password/i;\nfunction isSecret(key: string) {\n  return secrets.test(key);\n}\n\nexport function toCurl({ method, baseURL, url, data, headers }: AxiosRequestConfig) {\n  return [\n    `curl -X ${method.toUpperCase()}`,\n    `${baseURL}/${url.replace(/^\\//, '')}`,\n    Object.entries(headers)\n      .map(([key, value]) => `-H '${key}: ${isSecret(key) ? mask(String(value)) : value}'`)\n      .join(' '),\n    data && `-d '${JSON.stringify(data)}'`,\n  ].join(' ');\n}\n","export const hasOwn = (obj, prop) => Object.prototype.hasOwnProperty.call(obj, prop);\n\nexport const compose = <R>(fn1: (a: R) => R, ...fns: Array<(a: R) => R>) =>\n  fns.reduce((prevFn, nextFn) => (value) => prevFn(nextFn(value)), fn1);\n\nexport function isString(value) {\n  return typeof value === 'string';\n}\n\nexport function isBoolean(value) {\n  return typeof value === 'boolean';\n}\n\nexport function isArray(value) {\n  return Array.isArray(value);\n}\n\nexport function isStringArray(value) {\n  return Array.isArray(value) && value.every((x) => typeof x === 'string');\n}\n\nexport function isNumber(value) {\n  return typeof value === 'number';\n}\n\nexport function isObject(value) {\n  return value && typeof value === 'object';\n}\n\nexport function compact(obj: Record<string, unknown>, dropEmptyString = false) {\n  if (typeof obj !== 'object') {\n    throw new Error('Argument must be an object');\n  }\n\n  const result = {};\n  for (const key of Object.keys(obj)) {\n    if (obj[key] == null) continue;\n    if (dropEmptyString && obj[key] === '') continue;\n    result[key] = obj[key];\n  }\n\n  return result;\n}\n\nexport function uuid4() {\n  // TODO: should be upgradable to crypto.randomUUID(), introduced by node v14\n  return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, (c) => {\n    const r = (Math.random() * 16) | 0;\n    const v = c === 'x' ? r : (r & 0x3) | 0x8;\n    return v.toString(16);\n  });\n}\n\nexport async function sleep(ms: number) {\n  return new Promise((resolve) => setTimeout(resolve, ms));\n}\n\nexport function joinAnd(...parts) {\n  if (parts.length <= 2) return parts.join(' and ');\n\n  const last = parts.slice(-1)[0];\n  const others = parts.slice(0, -1);\n  return [others.join(', '), last].join(', and ');\n}\n\nexport function joinOr(...parts) {\n  if (parts.length <= 2) return parts.join(' or ');\n\n  const last = parts.slice(-1)[0];\n  const others = parts.slice(0, -1);\n  return [others.join(', '), last].join(', or ');\n}\n\nexport function joinUrlSegments(...segments) {\n  return ['/', ...segments].join('/').replace(/\\/+/g, '/').replace(/\\/$/, '');\n}\n","import { hasOwn } from './lib/utils';\n\nexport const ASYNC_ITERATOR_SYMBOL =\n  typeof Symbol !== 'undefined' && Symbol.asyncIterator ? Symbol.asyncIterator : '@@asyncIterator';\n\nfunction hasMore(pageResult) {\n  return (\n    hasOwn(pageResult, 'current_page') &&\n    hasOwn(pageResult, 'total_pages') &&\n    pageResult.current_page < pageResult.total_pages\n  );\n}\n\nexport function autoPaginate(makeRequest, { data, params }) {\n  const promiseCache = { currentPromise: null };\n  const reverseIteration = typeof params.after !== 'undefined';\n\n  let i = 0;\n  let request = makeRequest({ data, params });\n\n  const getNextPage = (pageResult) => {\n    const page = pageResult.current_page + 1;\n    return makeRequest({ data, params: { ...params, page } });\n  };\n\n  function iterate(pageResult) {\n    const dataKey = Object.keys(pageResult).find((key) => Array.isArray(pageResult[key]));\n    const data = pageResult[dataKey] || pageResult.data;\n\n    if (!data || typeof data.length !== 'number') {\n      throw Error('Unexpected: MagicBell API response does not have a well-formed response.');\n    }\n\n    if (i < data.length) {\n      const idx = reverseIteration ? data.length - 1 - i : i;\n      const value = data[idx];\n      i += 1;\n\n      return { value, done: false };\n    }\n\n    if (hasMore(pageResult)) {\n      // Reset counter, request next page, and recurse.\n      i = 0;\n      request = getNextPage(pageResult);\n      return request.then(iterate);\n    }\n\n    return { value: undefined, done: true };\n  }\n\n  function asyncIteratorNext() {\n    return memoizedPromise(promiseCache, (resolve, reject) => {\n      return request.then(iterate).then(resolve).catch(reject);\n    });\n  }\n\n  const forEach = makeForEach(asyncIteratorNext);\n  const toArray = makeToArray(forEach);\n\n  const autoPaginationMethods = {\n    forEach,\n    toArray,\n\n    next: asyncIteratorNext,\n    return: () => ({}),\n    [ASYNC_ITERATOR_SYMBOL]: () => {\n      return autoPaginationMethods;\n    },\n  };\n\n  return Object.assign(request, autoPaginationMethods);\n}\n\n/**\n * If a user calls `.next()` multiple times in parallel,\n * return the same result until something has resolved\n * to prevent page-turning race conditions.\n */\nfunction memoizedPromise(promiseCache, cb) {\n  if (promiseCache.currentPromise) {\n    return promiseCache.currentPromise;\n  }\n  promiseCache.currentPromise = new Promise(cb).then((ret) => {\n    promiseCache.currentPromise = undefined;\n    return ret;\n  });\n  return promiseCache.currentPromise;\n}\n\nexport function makeForEach(asyncIteratorNext, onDoneCallback?: () => void) {\n  return function forEach(onItem) {\n    return new Promise<void>((resolve, reject) => {\n      let idx = 0;\n      function handleIteration(iterResult) {\n        if (iterResult.done) {\n          resolve();\n          return;\n        }\n\n        const item = iterResult.value;\n        return new Promise((resolve) => {\n          resolve(onItem(item, idx));\n        }).then((shouldContinue) => {\n          if (shouldContinue === false) {\n            onDoneCallback?.();\n            return handleIteration({ done: true });\n          } else {\n            idx++;\n            return asyncIteratorNext().then(handleIteration);\n          }\n        });\n      }\n\n      asyncIteratorNext().then(handleIteration).catch(reject);\n    });\n  };\n}\n\nfunction makeToArray(forEach) {\n  return function toArray(options) {\n    const limit = options?.limit;\n    if (!limit) {\n      throw Error('You must pass a `limit` option to toArray, e.g., `toArray({ limit: 1000 });`.');\n    }\n\n    if (limit > 10_000) {\n      throw Error(\n        'You cannot specify a limit of more than 10,000 items to fetch in `toArray`; use `forEach` to iterate through longer lists.',\n      );\n    }\n\n    return new Promise((resolve, reject) => {\n      const items = [];\n      forEach((item) => {\n        items.push(item);\n        if (items.length >= limit) {\n          return false;\n        }\n      })\n        .then(() => {\n          resolve(items);\n        })\n        .catch(reject);\n    });\n  };\n}\n","import axios from 'axios';\nimport EventSource from 'eventsource';\n\nimport { Client } from './client';\nimport { ASYNC_ITERATOR_SYMBOL, makeForEach } from './paginate';\nimport { RequestOptions } from './types';\n\ntype AuthResponse = {\n  keyName: string;\n  timestamp: number;\n  nonce: string;\n  ttl: number;\n  mac: string;\n};\n\ntype TokenResponse = {\n  token: string;\n  keyName: string;\n  issued: number;\n  expires: number;\n  capability: string;\n  userClaims: string;\n};\n\ntype Event = {\n  id: string;\n  timestamp: number;\n  encoding: string;\n  channel: string;\n} & (\n  | { name: 'notifications/new'; data: { id: string } }\n  | { name: 'notifications/read'; data: { id: string; client_id: string } }\n  | { name: 'notifications/read/all'; data: { client_id: string } }\n  | { name: 'notifications/seen/all'; data: { client_id: string } }\n  | { name: 'notifications/unread'; data: { id: string; client_id: string } }\n  | { name: 'notifications/delete'; data: { id: string; client_id: string | null } }\n);\n\ntype IterableEventSource<TNode> = {\n  [Symbol.asyncIterator](): Iterator<TNode>;\n  forEach(cb: (node: TNode, index: number) => void | boolean | Promise<void | boolean>): Promise<void>;\n};\n\nexport type Listener = (options?: RequestOptions) => IterableEventSource<Event>;\n\nexport function createListener(client: InstanceType<typeof Client>, args: { sseHost?: string } = {}): Listener {\n  let eventSource: EventSource;\n  let channels: string;\n  let lastEvent: string;\n  let configPromise;\n\n  const messages: { value: Event; done: boolean }[] = [];\n  let resolve;\n\n  const pushMessage = (p) => {\n    messages.push(p);\n\n    if (resolve) {\n      resolve();\n      resolve = null;\n    }\n  };\n\n  // accept callback or yield\n  async function connect(options?: RequestOptions) {\n    // invoke optional config request in the background, as we only need it after the ably authentication\n    if (!channels && !configPromise) {\n      configPromise = client\n        .request({ method: 'GET', path: '/config' }, options)\n        .then((x) => (channels = x.ws.channel));\n    }\n\n    const auth = await client.request<AuthResponse>({ method: 'POST', path: '/ws/auth' }, options);\n\n    // authenticate against ably\n    const { token } = await axios\n      .post<TokenResponse>(`https://rest.ably.io/keys/${auth.keyName}/requestToken`, auth)\n      .then((x) => x.data);\n\n    // make sure that the optional config request has finished\n    await configPromise;\n\n    // establish a connection with that token, the only reason we allow passing in the sseHost via args,\n    // is so that we have a way to reroute to localhost for testing.\n    const sseHost = args.sseHost || 'https://realtime.ably.io';\n    const url = new URL('sse', sseHost);\n\n    url.searchParams.append('v', '1.1');\n    url.searchParams.append('accessToken', token);\n    url.searchParams.append('channels', channels);\n    url.searchParams.append('heartbeats', 'true');\n\n    if (lastEvent) {\n      url.searchParams.append('lastEvent', lastEvent);\n    }\n\n    if (eventSource) {\n      eventSource.close();\n    }\n\n    eventSource = new EventSource(url.toString());\n\n    // handle incoming messages\n    eventSource.onmessage = (event) => {\n      if (event.origin !== sseHost) return;\n\n      lastEvent = event.lastEventId;\n      if (!('data' in event)) return;\n\n      const message = JSON.parse(event.data);\n      if (message.type === 'close') {\n        return pushMessage({ value: null, done: true });\n      }\n\n      message.data = message.encoding === 'json' ? JSON.parse(message.data) : message.data;\n      pushMessage({ value: message, done: false });\n    };\n\n    // handle connection errors\n    eventSource.onerror = (msg) => {\n      const err = 'data' in msg ? JSON.parse((msg as any).data) : {};\n      const isTokenErr = err.code >= 40140 && err.code < 40150;\n      if (isTokenErr) {\n        eventSource.close();\n        connect(options);\n      } else if (/invalid channel id/i.test(err.message)) {\n        eventSource.close();\n        pushMessage({ value: null, done: true });\n      } else {\n        // eslint-disable-next-line no-console\n        console.log('err', msg);\n      }\n    };\n  }\n\n  function listen(options?: RequestOptions): IterableEventSource<Event> {\n    void connect(options);\n\n    const asyncIteratorNext = async () => {\n      if (!messages.length) await new Promise((r) => (resolve = r));\n      const event = messages.pop();\n      if (event.done && eventSource) eventSource.close();\n      return event;\n    };\n\n    const dispose = () => {\n      eventSource.close();\n      return { done: true, value: undefined };\n    };\n\n    const forEach = makeForEach(asyncIteratorNext, dispose);\n    const autoPaginationMethods = {\n      forEach,\n\n      next: asyncIteratorNext,\n      return: dispose,\n      [ASYNC_ITERATOR_SYMBOL]: () => {\n        return autoPaginationMethods;\n      },\n    };\n\n    return autoPaginationMethods;\n  }\n\n  return listen;\n}\n","import { isBoolean, isNumber, isObject, isString } from './lib/utils';\nimport { ClientOptions } from './types';\n\nconst optionValidators: Record<keyof ClientOptions, (value: unknown) => boolean> = {\n  host: isString,\n  maxRetryDelay: isNumber,\n  timeout: isNumber,\n  apiKey: isString,\n  maxRetries: isNumber,\n  userEmail: isString,\n  userExternalId: isString,\n  userHmac: isString,\n  idempotencyKey: isString,\n  telemetry: isBoolean,\n  apiSecret: isString,\n  appInfo: isObject,\n  debug: isBoolean,\n  features: isObject,\n};\n\nexport function isOptionsHash(object) {\n  if (!isObject(object)) return false;\n\n  for (const key of Object.keys(object)) {\n    if (!optionValidators[key]?.(object[key])) return false;\n  }\n\n  return true;\n}\n","import { isArray, isBoolean, isObject, isString, isStringArray } from './lib/utils';\nimport { isOptionsHash } from './options';\nimport { ClientOptions, RequestMethod } from './types';\n\ntype KeyOfType<T, V> = keyof {\n  [P in keyof T as T[P] extends V ? P : never]: any;\n};\n\nexport type IterablePromise<\n  TData,\n  TKey extends KeyOfType<TData, Array<unknown>> = KeyOfType<TData, Array<unknown>>,\n  TNode = TData[TKey] extends Array<unknown> ? TData[TKey][number] : never,\n> = Promise<TData> & {\n  [Symbol.asyncIterator](): Iterator<TNode>;\n  forEach(cb: (node: TNode, index: number) => void | boolean | Promise<void | boolean>): Promise<void>;\n  toArray(options: { limit: number }): Promise<Array<TNode>>;\n};\n\nconst queryParamValidators = {\n  archived: isBoolean,\n  read: isBoolean,\n  seen: isBoolean,\n  categories: (value) => isString(value) || isStringArray(value),\n  topics: (value) => isString(value) || isStringArray(value),\n};\n\nfunction isForcedQueryParams(object) {\n  if (!isObject(object)) return false;\n\n  for (const key of Object.keys(object)) {\n    if (!queryParamValidators[key]?.(object[key])) return false;\n  }\n\n  return true;\n}\n\nfunction getUrl(path: string, params: Record<string, string>, options = { encode: true }) {\n  return path.replace(/{([\\s\\S]+?)}/g, ($0, $1) =>\n    options.encode ? encodeURIComponent(params[$1] || '') : params[$1] || '',\n  );\n}\n\nfunction extractUrlParams(path: string) {\n  const params = path.match(/{\\w+}/g) || [];\n  return (params || []).map((param) => param.replace(/[{}]/g, ''));\n}\n\n/**\n * Return the data argument from a list of arguments\n *\n * @param {object[]} args\n * @returns {object}\n */\nfunction getDataFromArgs(args): Record<string, unknown> {\n  if (!isArray(args) || !isObject(args[0])) return {};\n  if (isOptionsHash(args[0])) return {};\n  return args.shift();\n}\n\n/**\n * Return the options hash from a list of arguments\n */\nfunction getOptionsFromArgs(args): Partial<ClientOptions> {\n  if (!isArray(args) || args.length === 0) return {};\n\n  const arg = args[args.length - 1];\n  if (!isOptionsHash(arg)) return {};\n\n  return { ...args.pop() };\n}\n\nexport function normalizeArgs({\n  path,\n  method,\n  args,\n}: {\n  path: string;\n  method: RequestMethod;\n  args: (Record<string, unknown> | string)[];\n}) {\n  const argsCopy = [...args].filter((x) => x !== undefined);\n\n  const urlParams = extractUrlParams(path);\n  const urlData = urlParams.reduce((urlData, param) => {\n    const arg = argsCopy.shift();\n    if (typeof arg !== 'string') {\n      throw new Error(\n        `MagicBell: Argument \"${param}\" must be a string, but got ${typeof arg}: ${JSON.stringify(\n          arg,\n        )} (on API request to \\`${method} ${path}\\`)`,\n      );\n    }\n\n    urlData[param] = arg;\n    return urlData;\n  }, {});\n\n  // We don't encode atm because the backend doesn't support that in PUT /users/email:user@domain.com\n  const url = getUrl(path, urlData, { encode: false });\n  const dataFromArgs = getDataFromArgs(argsCopy);\n  const options = getOptionsFromArgs(argsCopy);\n\n  // Validate that there are no more args.\n  if (argsCopy.filter((x) => x != null).length) {\n    throw new Error(\n      `MagicBell: Unknown arguments (${JSON.stringify(argsCopy)}). (on API request to \\`${method} ${url}\\`)`,\n    );\n  }\n\n  // Note, DELETE requests should have data in the params, but our `subscriptions.delete`\n  //   endpoint reads it from the body. Other delete requests don't have data, so this seems\n  //   to be the best solution for now.\n  let dataInQuery = method === 'GET'; // || method === 'DELETE';\n\n  // We have a few POST methods using query data instead of body data.\n  if (method === 'POST' && isForcedQueryParams(dataFromArgs)) {\n    dataInQuery = true;\n  }\n\n  const data = dataInQuery ? {} : dataFromArgs;\n  const params = dataInQuery ? dataFromArgs : {};\n\n  return { path: url, data, params, options };\n}\n","import { Client } from './client';\nimport { joinUrlSegments } from './lib/utils';\nimport { IterablePromise, normalizeArgs } from './method';\nimport { autoPaginate } from './paginate';\n\ntype ResourceRequestOptions = {\n  method: 'GET' | 'PUT' | 'POST' | 'DELETE' | 'PATCH';\n  path?: string;\n  paged?: boolean;\n};\n\nfunction isEmptyPayload(data: unknown): boolean {\n  if (!data) return true;\n  if (Array.isArray(data)) return data.length === 0;\n  if (typeof data === 'object') return Object.keys(data).length === 0;\n  return false;\n}\n\nexport class Resource {\n  path: string;\n  entity: string;\n\n  protected client: InstanceType<typeof Client>;\n\n  constructor(client: InstanceType<typeof Client>) {\n    this.client = client;\n  }\n\n  protected request<TData = any>(\n    options: ResourceRequestOptions & { paged: true },\n    ...args: (string | Record<string, unknown>)[]\n  ): IterablePromise<TData>;\n\n  protected request<TData = any>(\n    options: ResourceRequestOptions & { paged?: false | never },\n    ...args: (string | Record<string, unknown>)[]\n  ): Promise<TData>;\n\n  protected request(\n    { method, paged, path: tplPath }: ResourceRequestOptions,\n    ...args: (string | Record<string, unknown>)[]\n  ) {\n    const { path, data, params, options } = normalizeArgs({\n      path: joinUrlSegments(this.path, tplPath),\n      method,\n      args,\n    });\n\n    const makeRequest = ({ data, params }) => {\n      const entity = this.entity || this.path;\n      data = isEmptyPayload(data) ? undefined : { [entity]: data };\n      params = isEmptyPayload(params) ? undefined : params;\n\n      return this.client\n        .request({ method, path, data, params }, options)\n        .then((response) => response[entity] || response);\n    };\n\n    if (paged) {\n      return autoPaginate(makeRequest, {\n        data,\n        params,\n      });\n    }\n\n    return makeRequest({ data, params });\n  }\n\n  protected assertFeatureFlag(flag: string) {\n    if (!this.client.hasFlag(flag)) {\n      throw new Error(`This is a beta feature, please enable it by providing the \"${flag}\" feature flag.`);\n    }\n  }\n}\n","// This file is generated. Do not update manually!\n\nimport { type FromSchema } from 'json-schema-to-ts';\n\nimport { Resource } from '../resource';\nimport * as schemas from '../schemas/imports';\nimport { type RequestOptions } from '../types';\n\ntype CreateImportsResponse = FromSchema<typeof schemas.CreateImportsResponseSchema>;\ntype CreateImportsPayload = FromSchema<typeof schemas.CreateImportsPayloadSchema>;\ntype GetImportsResponse = FromSchema<typeof schemas.GetImportsResponseSchema>;\n\nexport class Imports extends Resource {\n  path = 'imports';\n  entity = 'import';\n\n  /**\n   * Send a request to start the import of a list of users. The import allows the\n   * creation of slack connections as well.\n   *\n   * @param options - override client request options.\n   * @returns\n   **/\n  create(options?: RequestOptions): Promise<CreateImportsResponse>;\n\n  /**\n   * Send a request to start the import of a list of users. The import allows the\n   * creation of slack connections as well.\n   *\n   * @param data\n   * @param options - override client request options.\n   * @returns\n   **/\n  create(data: CreateImportsPayload, options?: RequestOptions): Promise<CreateImportsResponse>;\n\n  create(\n    dataOrOptions: CreateImportsPayload | RequestOptions,\n    options?: RequestOptions,\n  ): Promise<CreateImportsResponse> {\n    return this.request(\n      {\n        method: 'POST',\n      },\n      dataOrOptions,\n      options,\n    );\n  }\n\n  /**\n   * Send a request to query the status & errors of the import.\n   *\n   * @param importId - ID of the import.\n   *   The ID of the import is returned when the import is created.\n   * @param options - override client request options.\n   * @returns\n   **/\n  get(importId: string, options?: RequestOptions): Promise<GetImportsResponse> {\n    return this.request(\n      {\n        method: 'GET',\n        path: '{import_id}',\n      },\n      importId,\n      options,\n    );\n  }\n}\n","// This file is generated. Do not update manually!\n\nimport { type FromSchema } from 'json-schema-to-ts';\n\nimport { Resource } from '../resource';\nimport * as schemas from '../schemas/notification-preferences';\nimport { type RequestOptions } from '../types';\n\ntype GetNotificationPreferencesResponse = FromSchema<typeof schemas.GetNotificationPreferencesResponseSchema>;\ntype UpdateNotificationPreferencesResponse = FromSchema<typeof schemas.UpdateNotificationPreferencesResponseSchema>;\ntype UpdateNotificationPreferencesPayload = FromSchema<typeof schemas.UpdateNotificationPreferencesPayloadSchema>;\n\nexport class NotificationPreferences extends Resource {\n  path = 'notification_preferences';\n  entity = 'notification_preferences';\n\n  /**\n   * Fetch a user's notification preferences. If a user does not disable a channel\n   * explicitly, we would send notifications through that channel as long as your\n   * project is enabled.\n   *\n   * @param options - override client request options.\n   * @returns\n   **/\n  get(options?: RequestOptions): Promise<GetNotificationPreferencesResponse> {\n    return this.request(\n      {\n        method: 'GET',\n      },\n      options,\n    );\n  }\n\n  /**\n   * Update a user's notification preferences. These preferences will be applied only\n   * to channels you enabled for your project.\n   *\n   * @param options - override client request options.\n   * @returns\n   **/\n  update(options?: RequestOptions): Promise<UpdateNotificationPreferencesResponse>;\n\n  /**\n   * Update a user's notification preferences. These preferences will be applied only\n   * to channels you enabled for your project.\n   *\n   * @param data\n   * @param options - override client request options.\n   * @returns\n   **/\n  update(\n    data: UpdateNotificationPreferencesPayload,\n    options?: RequestOptions,\n  ): Promise<UpdateNotificationPreferencesResponse>;\n\n  update(\n    dataOrOptions: UpdateNotificationPreferencesPayload | RequestOptions,\n    options?: RequestOptions,\n  ): Promise<UpdateNotificationPreferencesResponse> {\n    return this.request(\n      {\n        method: 'PUT',\n      },\n      dataOrOptions,\n      options,\n    );\n  }\n}\n","// This file is generated. Do not update manually!\n\nimport { type FromSchema } from 'json-schema-to-ts';\n\nimport { type IterablePromise } from '../method';\nimport { Resource } from '../resource';\nimport * as schemas from '../schemas/notifications';\nimport { type RequestOptions } from '../types';\n\ntype CreateNotificationsResponse = FromSchema<typeof schemas.CreateNotificationsResponseSchema>;\ntype CreateNotificationsPayload = FromSchema<typeof schemas.CreateNotificationsPayloadSchema>;\ntype ListNotificationsResponse = FromSchema<typeof schemas.ListNotificationsResponseSchema>;\ntype ListNotificationsPayload = FromSchema<typeof schemas.ListNotificationsPayloadSchema>;\ntype GetNotificationsResponse = FromSchema<typeof schemas.GetNotificationsResponseSchema>;\ntype MarkAllReadNotificationsPayload = FromSchema<typeof schemas.MarkAllReadNotificationsPayloadSchema>;\ntype MarkAllSeenNotificationsPayload = FromSchema<typeof schemas.MarkAllSeenNotificationsPayloadSchema>;\n\nexport class Notifications extends Resource {\n  path = 'notifications';\n  entity = 'notification';\n\n  /**\n   * Send a notification to one or multiple users. You can identify users by their\n   * email address or by an external_id.\n   *\n   * You don't have to import your users into MagicBell. If a user does not exist\n   * we'll create it automatically.\n   *\n   * You can send user attributes like first_name, custom_attributes, and more when\n   * creating a notification.\n   *\n   * The new notification will be shown in the notification inbox of each recipient\n   * in real-time. It will also be delivered to each recipient through all channels\n   * you have enabled for your MagicBell project.\n   *\n   * @param data\n   * @param options - override client request options.\n   * @returns\n   **/\n  create(data: CreateNotificationsPayload, options?: RequestOptions): Promise<CreateNotificationsResponse> {\n    return this.request(\n      {\n        method: 'POST',\n      },\n      data,\n      options,\n    );\n  }\n\n  /**\n   * Fetch a user's notifications. Notifications are sorted in descendent order by\n   * the sent_at timestamp.\n   *\n   * @param options - override client request options.\n   * @returns\n   **/\n  list(options?: RequestOptions): IterablePromise<ListNotificationsResponse>;\n\n  /**\n   * Fetch a user's notifications. Notifications are sorted in descendent order by\n   * the sent_at timestamp.\n   *\n   * @param data\n   * @param options - override client request options.\n   * @returns\n   **/\n  list(data: ListNotificationsPayload, options?: RequestOptions): IterablePromise<ListNotificationsResponse>;\n\n  list(\n    dataOrOptions: ListNotificationsPayload | RequestOptions,\n    options?: RequestOptions,\n  ): IterablePromise<ListNotificationsResponse> {\n    return this.request(\n      {\n        method: 'GET',\n        paged: true,\n      },\n      dataOrOptions,\n      options,\n    );\n  }\n\n  /**\n   * Fetch a user's notification by its ID.\n   *\n   * @param notificationId - ID of the user notification.\n   *   The ID of a user notification can be obtained from the \"Fetch user\n   *   notifications\" API endpoint or from push events sent to the MagicBell React\n   *   library.\n   *\n   * @param options - override client request options.\n   * @returns\n   **/\n  get(notificationId: string, options?: RequestOptions): Promise<GetNotificationsResponse> {\n    return this.request(\n      {\n        method: 'GET',\n        path: '{notification_id}',\n      },\n      notificationId,\n      options,\n    );\n  }\n\n  /**\n   * Delete a user's notification by its ID. The notification is deleted immediately\n   * and removed from the user's notification inbox in real-time.\n   *\n   * @param notificationId - ID of the user notification.\n   *   The ID of a user notification can be obtained from the \"Fetch user\n   *   notifications\" API endpoint or from push events sent to the MagicBell React\n   *   library.\n   *\n   * @param options - override client request options.\n   **/\n  delete(notificationId: string, options?: RequestOptions): Promise<void> {\n    return this.request(\n      {\n        method: 'DELETE',\n        path: '{notification_id}',\n      },\n      notificationId,\n      options,\n    );\n  }\n\n  /**\n   * Mark a user notification as read. The notification will be automatically marked\n   * as seen, too.\n   *\n   * The new state will be reflected in the user's notification inbox in real-time.\n   *\n   * @param notificationId - ID of the user notification.\n   *   The ID of a user notification can be obtained from the \"Fetch user\n   *   notifications\" API endpoint or from push events sent to the MagicBell React\n   *   library.\n   *\n   * @param options - override client request options.\n   **/\n  markAsRead(notificationId: string, options?: RequestOptions): Promise<void> {\n    return this.request(\n      {\n        method: 'POST',\n        path: '{notification_id}/read',\n      },\n      notificationId,\n      options,\n    );\n  }\n\n  /**\n   * Mark a user notification as unread. The new state will be reflected in the\n   * user's notification inbox in real-time.\n   *\n   * @param notificationId - ID of the user notification.\n   *   The ID of a user notification can be obtained from the \"Fetch user\n   *   notifications\" API endpoint or from push events sent to the MagicBell React\n   *   library.\n   *\n   * @param options - override client request options.\n   **/\n  markAsUnread(notificationId: string, options?: RequestOptions): Promise<void> {\n    return this.request(\n      {\n        method: 'POST',\n        path: '{notification_id}/unread',\n      },\n      notificationId,\n      options,\n    );\n  }\n\n  /**\n   * Mark a user notification as archived.\n   *\n   * @param notificationId - ID of the user notification.\n   *   The ID of a user notification can be obtained from the \"Fetch user\n   *   notifications\" API endpoint or from push events sent to the MagicBell React\n   *   library.\n   *\n   * @param options - override client request options.\n   **/\n  archive(notificationId: string, options?: RequestOptions): Promise<void> {\n    return this.request(\n      {\n        method: 'POST',\n        path: '{notification_id}/archive',\n      },\n      notificationId,\n      options,\n    );\n  }\n\n  /**\n   * Mark a user notification as unarchived.\n   *\n   * @param notificationId - ID of the user notification.\n   *   The ID of a user notification can be obtained from the \"Fetch user\n   *   notifications\" API endpoint or from push events sent to the MagicBell React\n   *   library.\n   *\n   * @param options - override client request options.\n   **/\n  unarchive(notificationId: string, options?: RequestOptions): Promise<void> {\n    return this.request(\n      {\n        method: 'DELETE',\n        path: '{notification_id}/archive',\n      },\n      notificationId,\n      options,\n    );\n  }\n\n  /**\n   * Mark all notifications of a user as read. When you call this endpoint, the\n   * notification inboxes of this user will be updated in real-time.\n   *\n   * @param options - override client request options.\n   **/\n  markAllRead(options?: RequestOptions): Promise<void>;\n\n  /**\n   * Mark all notifications of a user as read. When you call this endpoint, the\n   * notification inboxes of this user will be updated in real-time.\n   *\n   * @param data\n   * @param options - override client request options.\n   **/\n  markAllRead(data: MarkAllReadNotificationsPayload, options?: RequestOptions): Promise<void>;\n\n  markAllRead(\n    dataOrOptions: MarkAllReadNotificationsPayload | RequestOptions,\n    options?: RequestOptions,\n  ): Promise<void> {\n    return this.request(\n      {\n        method: 'POST',\n        path: 'read',\n      },\n      dataOrOptions,\n      options,\n    );\n  }\n\n  /**\n   * Mark all notifications of a user as seen. When you call this endpoint, the\n   * notification inboxes of this user will be updated in real-time.\n   *\n   * @param options - override client request options.\n   **/\n  markAllSeen(options?: RequestOptions): Promise<void>;\n\n  /**\n   * Mark all notifications of a user as seen. When you call this endpoint, the\n   * notification inboxes of this user will be updated in real-time.\n   *\n   * @param data\n   * @param options - override client request options.\n   **/\n  markAllSeen(data: MarkAllSeenNotificationsPayload, options?: RequestOptions): Promise<void>;\n\n  markAllSeen(\n    dataOrOptions: MarkAllSeenNotificationsPayload | RequestOptions,\n    options?: RequestOptions,\n  ): Promise<void> {\n    return this.request(\n      {\n        method: 'POST',\n        path: 'seen',\n      },\n      dataOrOptions,\n      options,\n    );\n  }\n}\n","// This file is generated. Do not update manually!\n\nimport { type FromSchema } from 'json-schema-to-ts';\n\nimport { Resource } from '../resource';\nimport * as schemas from '../schemas/push-subscriptions';\nimport { type RequestOptions } from '../types';\n\ntype CreatePushSubscriptionsResponse = FromSchema<typeof schemas.CreatePushSubscriptionsResponseSchema>;\ntype CreatePushSubscriptionsPayload = FromSchema<typeof schemas.CreatePushSubscriptionsPayloadSchema>;\n\nexport class PushSubscriptions extends Resource {\n  path = 'push_subscriptions';\n  entity = 'push_subscription';\n\n  /**\n   * Register a device token for push notifications.\n   *\n   * Please keep in mind that mobile push notifications will be delivered to this\n   * device only if the channel is configured and enabled.\n   *\n   * @param data\n   * @param options - override client request options.\n   * @returns\n   *\n   * @beta\n   **/\n  create(data: CreatePushSubscriptionsPayload, options?: RequestOptions): Promise<CreatePushSubscriptionsResponse> {\n    this.assertFeatureFlag('push-subscriptions-create');\n\n    return this.request(\n      {\n        method: 'POST',\n      },\n      data,\n      options,\n    );\n  }\n\n  /**\n   * Remove the subscription of a device to mobile push notifications. The device\n   * will be discarded immediately.\n   *\n   * @param deviceToken - Token of the device you want to remove\n   * @param options - override client request options.\n   *\n   * @beta\n   **/\n  delete(deviceToken: string, options?: RequestOptions): Promise<void> {\n    this.assertFeatureFlag('push-subscriptions-delete');\n\n    return this.request(\n      {\n        method: 'DELETE',\n        path: '{device_token}',\n      },\n      deviceToken,\n      options,\n    );\n  }\n}\n","// This file is generated. Do not update manually!\n\nimport { type FromSchema } from 'json-schema-to-ts';\n\nimport { type IterablePromise } from '../method';\nimport { Resource } from '../resource';\nimport * as schemas from '../schemas/subscriptions';\nimport { type RequestOptions } from '../types';\n\ntype ListSubscriptionsResponse = FromSchema<typeof schemas.ListSubscriptionsResponseSchema>;\ntype CreateSubscriptionsResponse = FromSchema<typeof schemas.CreateSubscriptionsResponseSchema>;\ntype CreateSubscriptionsPayload = FromSchema<typeof schemas.CreateSubscriptionsPayloadSchema>;\ntype UnsubscribeSubscriptionsResponse = FromSchema<typeof schemas.UnsubscribeSubscriptionsResponseSchema>;\ntype UnsubscribeSubscriptionsPayload = FromSchema<typeof schemas.UnsubscribeSubscriptionsPayloadSchema>;\ntype GetSubscriptionsResponse = FromSchema<typeof schemas.GetSubscriptionsResponseSchema>;\ntype DeleteSubscriptionsPayload = FromSchema<typeof schemas.DeleteSubscriptionsPayloadSchema>;\n\nexport class Subscriptions extends Resource {\n  path = 'subscriptions';\n  entity = 'subscription';\n\n  /**\n   * List a user's subscriptions status for all topics and categories.\n   *\n   * @param options - override client request options.\n   * @returns\n   **/\n  list(options?: RequestOptions): IterablePromise<ListSubscriptionsResponse> {\n    return this.request(\n      {\n        method: 'GET',\n        paged: true,\n      },\n      options,\n    );\n  }\n\n  /**\n   * Set a user's subscription status to subscribed for a particular topic (and\n   * optional categories). If the user previously unsubscribed, the user will be\n   * resubscribed.\n   *\n   * @param data\n   * @param options - override client request options.\n   * @returns\n   **/\n  create(data: CreateSubscriptionsPayload, options?: RequestOptions): Promise<CreateSubscriptionsResponse> {\n    return this.request(\n      {\n        method: 'POST',\n      },\n      data,\n      options,\n    );\n  }\n\n  /**\n   * Unusbscribe a user from a particular topic (and optional categories).\n   *\n   * @param topic - The topic for which we'd like to filter topic subscriptions.\n   * @param data\n   * @param options - override client request options.\n   * @returns\n   **/\n  unsubscribe(\n    topic: string,\n    data: UnsubscribeSubscriptionsPayload,\n    options?: RequestOptions,\n  ): Promise<UnsubscribeSubscriptionsResponse> {\n    return this.request(\n      {\n        method: 'POST',\n        path: '{topic}/unsubscribe',\n      },\n      topic,\n      data,\n      options,\n    );\n  }\n\n  /**\n   * Show a user's subscription status for a particular topic and categories.\n   *\n   * @param topic - The topic for which we'd like to filter topic subscriptions.\n   * @param options - override client request options.\n   * @returns\n   **/\n  get(topic: string, options?: RequestOptions): Promise<GetSubscriptionsResponse> {\n    return this.request(\n      {\n        method: 'GET',\n        path: '{topic}',\n      },\n      topic,\n      options,\n    );\n  }\n\n  /**\n   * Delete topic subscription(s)\n   *\n   * @param topic - The topic for which we'd like to filter topic subscriptions.\n   * @param options - override client request options.\n   **/\n  delete(topic: string, options?: RequestOptions): Promise<void>;\n\n  /**\n   * Delete topic subscription(s)\n   *\n   * @param topic - The topic for which we'd like to filter topic subscriptions.\n   * @param data\n   * @param options - override client request options.\n   **/\n  delete(topic: string, data: DeleteSubscriptionsPayload, options?: RequestOptions): Promise<void>;\n\n  delete(\n    topic: string,\n    dataOrOptions: DeleteSubscriptionsPayload | RequestOptions,\n    options?: RequestOptions,\n  ): Promise<void> {\n    return this.request(\n      {\n        method: 'DELETE',\n        path: '{topic}',\n      },\n      topic,\n      dataOrOptions,\n      options,\n    );\n  }\n}\n","// This file is generated. Do not update manually!\n\nimport { type FromSchema } from 'json-schema-to-ts';\n\nimport { Resource } from '../resource';\nimport * as schemas from '../schemas/users';\nimport { type RequestOptions } from '../types';\n\ntype CreateUsersResponse = FromSchema<typeof schemas.CreateUsersResponseSchema>;\ntype CreateUsersPayload = FromSchema<typeof schemas.CreateUsersPayloadSchema>;\ntype UpdateUsersResponse = FromSchema<typeof schemas.UpdateUsersResponseSchema>;\ntype UpdateUsersPayload = FromSchema<typeof schemas.UpdateUsersPayloadSchema>;\ntype UpdateByEmailUsersResponse = FromSchema<typeof schemas.UpdateByEmailUsersResponseSchema>;\ntype UpdateByEmailUsersPayload = FromSchema<typeof schemas.UpdateByEmailUsersPayloadSchema>;\ntype UpdateByExternalIdUsersResponse = FromSchema<typeof schemas.UpdateByExternalIdUsersResponseSchema>;\ntype UpdateByExternalIdUsersPayload = FromSchema<typeof schemas.UpdateByExternalIdUsersPayloadSchema>;\n\nexport class Users extends Resource {\n  path = 'users';\n  entity = 'user';\n\n  /**\n   * Create a user. Please note that you must provide the user's email or the\n   * external id so MagicBell can uniquely identify the user.\n   *\n   * The external id, if provided, must be unique to the user.\n   *\n   * @param options - override client request options.\n   * @returns\n   **/\n  create(options?: RequestOptions): Promise<CreateUsersResponse>;\n\n  /**\n   * Create a user. Please note that you must provide the user's email or the\n   * external id so MagicBell can uniquely identify the user.\n   *\n   * The external id, if provided, must be unique to the user.\n   *\n   * @param data\n   * @param options - override client request options.\n   * @returns\n   **/\n  create(data: CreateUsersPayload, options?: RequestOptions): Promise<CreateUsersResponse>;\n\n  create(dataOrOptions: CreateUsersPayload | RequestOptions, options?: RequestOptions): Promise<CreateUsersResponse> {\n    return this.request(\n      {\n        method: 'POST',\n      },\n      dataOrOptions,\n      options,\n    );\n  }\n\n  /**\n   * Update a user's data. If you identify users by their email addresses, you need\n   * to update the MagicBell data, so this user can still access their notifications.\n   *\n   * @param userId - The user id is the MagicBell user id. Alternatively, provide an\n   *   id like `email:theusersemail@example.com` or `external_id:theusersexternalid` as\n   *   the user id.\n   * @param options - override client request options.\n   * @returns\n   **/\n  update(userId: string, options?: RequestOptions): Promise<UpdateUsersResponse>;\n\n  /**\n   * Update a user's data. If you identify users by their email addresses, you need\n   * to update the MagicBell data, so this user can still access their notifications.\n   *\n   * @param userId - The user id is the MagicBell user id. Alternatively, provide an\n   *   id like `email:theusersemail@example.com` or `external_id:theusersexternalid` as\n   *   the user id.\n   * @param data\n   * @param options - override client request options.\n   * @returns\n   **/\n  update(userId: string, data: UpdateUsersPayload, options?: RequestOptions): Promise<UpdateUsersResponse>;\n\n  update(\n    userId: string,\n    dataOrOptions: UpdateUsersPayload | RequestOptions,\n    options?: RequestOptions,\n  ): Promise<UpdateUsersResponse> {\n    return this.request(\n      {\n        method: 'PUT',\n        path: '{user_id}',\n      },\n      userId,\n      dataOrOptions,\n      options,\n    );\n  }\n\n  /**\n   * Immediately deletes a user.\n   *\n   * @param userId - The user id is the MagicBell user id. Alternatively, provide an\n   *   id like `email:theusersemail@example.com` or `external_id:theusersexternalid` as\n   *   the user id.\n   * @param options - override client request options.\n   **/\n  delete(userId: string, options?: RequestOptions): Promise<void> {\n    return this.request(\n      {\n        method: 'DELETE',\n        path: '{user_id}',\n      },\n      userId,\n      options,\n    );\n  }\n\n  /**\n   * Update a user's data. If you identify users by their email addresses, you need\n   * to update the MagicBell data, so this user can still access their notifications.\n   *\n   * @param userEmail\n   * @param options - override client request options.\n   * @returns\n   **/\n  updateByEmail(userEmail: string, options?: RequestOptions): Promise<UpdateByEmailUsersResponse>;\n\n  /**\n   * Update a user's data. If you identify users by their email addresses, you need\n   * to update the MagicBell data, so this user can still access their notifications.\n   *\n   * @param userEmail\n   * @param data\n   * @param options - override client request options.\n   * @returns\n   **/\n  updateByEmail(\n    userEmail: string,\n    data: UpdateByEmailUsersPayload,\n    options?: RequestOptions,\n  ): Promise<UpdateByEmailUsersResponse>;\n\n  updateByEmail(\n    userEmail: string,\n    dataOrOptions: UpdateByEmailUsersPayload | RequestOptions,\n    options?: RequestOptions,\n  ): Promise<UpdateByEmailUsersResponse> {\n    return this.request(\n      {\n        method: 'PUT',\n        path: 'email:{user_email}',\n      },\n      userEmail,\n      dataOrOptions,\n      options,\n    );\n  }\n\n  /**\n   * Immediately deletes a user.\n   *\n   * @param userEmail\n   * @param options - override client request options.\n   **/\n  deleteByEmail(userEmail: string, options?: RequestOptions): Promise<void> {\n    return this.request(\n      {\n        method: 'DELETE',\n        path: 'email:{user_email}',\n      },\n      userEmail,\n      options,\n    );\n  }\n\n  /**\n   * Update a user's data. If you identify users by their email addresses, you need\n   * to update the MagicBell data, so this user can still access their notifications.\n   *\n   * @param externalId\n   * @param options - override client request options.\n   * @returns\n   **/\n  updateByExternalId(externalId: string, options?: RequestOptions): Promise<UpdateByExternalIdUsersResponse>;\n\n  /**\n   * Update a user's data. If you identify users by their email addresses, you need\n   * to update the MagicBell data, so this user can still access their notifications.\n   *\n   * @param externalId\n   * @param data\n   * @param options - override client request options.\n   * @returns\n   **/\n  updateByExternalId(\n    externalId: string,\n    data: UpdateByExternalIdUsersPayload,\n    options?: RequestOptions,\n  ): Promise<UpdateByExternalIdUsersResponse>;\n\n  updateByExternalId(\n    externalId: string,\n    dataOrOptions: UpdateByExternalIdUsersPayload | RequestOptions,\n    options?: RequestOptions,\n  ): Promise<UpdateByExternalIdUsersResponse> {\n    return this.request(\n      {\n        method: 'PUT',\n        path: 'external_id:{external_id}',\n      },\n      externalId,\n      dataOrOptions,\n      options,\n    );\n  }\n\n  /**\n   * Immediately deletes a user.\n   *\n   * @param externalId\n   * @param options - override client request options.\n   **/\n  deleteByExternalId(externalId: string, options?: RequestOptions): Promise<void> {\n    return this.request(\n      {\n        method: 'DELETE',\n        path: 'external_id:{external_id}',\n      },\n      externalId,\n      options,\n    );\n  }\n}\n","import axios, { AxiosError, AxiosResponse } from 'axios';\n\nimport { createHmac } from './lib/crypto';\nimport { getClientUserAgent, getUserAgent } from './lib/env';\nimport { createError } from './lib/error';\nimport { normalizeHeaders } from './lib/headers';\nimport { Logger, toCurl } from './lib/log';\nimport { compact, hasOwn, joinAnd, sleep, uuid4 } from './lib/utils';\nimport { createListener } from './listen';\nimport { isOptionsHash } from './options';\nimport { Imports } from './resources/imports';\nimport { NotificationPreferences } from './resources/notification-preferences';\nimport { Notifications } from './resources/notifications';\nimport { PushSubscriptions } from './resources/push-subscriptions';\nimport { Subscriptions } from './resources/subscriptions';\nimport { Users } from './resources/users';\nimport { ClientOptions, RequestArgs, RequestMethod, RequestOptions } from './types';\n\n// some environments, like vscode extensions, don't have the XMLHttpRequest object defined.\nif (typeof XMLHttpRequest !== 'function') {\n  axios.defaults.adapter = require('axios/lib/adapters/http');\n}\n\nexport const DEFAULT_OPTIONS: Partial<ClientOptions> = {\n  host: 'https://api.magicbell.com',\n  timeout: 30_000,\n  maxRetries: 3,\n  maxRetryDelay: 60,\n  telemetry: true,\n};\n\ntype Telemetry = { id: string; runtime: number; duration: number; status: number };\n\nexport class Client {\n  #userAgent: string;\n  #clientUserAgent: string;\n  #options: ClientOptions;\n  #logger = new Logger();\n  #features: Record<string, boolean> = {};\n  #lastRequest: Telemetry[] = [];\n  listen = createListener(this);\n\n  imports = new Imports(this);\n  notificationPreferences = new NotificationPreferences(this);\n  notifications = new Notifications(this);\n  pushSubscriptions = new PushSubscriptions(this);\n  subscriptions = new Subscriptions(this);\n  users = new Users(this);\n\n  constructor(options: ClientOptions) {\n    const missingOptions = ['apiKey'].filter((x) => !hasOwn(options, x));\n    if (missingOptions.length) {\n      throw new Error(\n        `You haven't provided all required options, please provide ${joinAnd(...missingOptions)} to Client(options)`,\n      );\n    }\n\n    if (!isOptionsHash(options)) {\n      throw new Error(`You have provided invalid options. Please check your client options.`);\n    }\n\n    this.#options = Object.assign({}, DEFAULT_OPTIONS, options);\n    this.#logger.active = Boolean(this.#options.debug);\n    this.#clientUserAgent = getClientUserAgent(options.appInfo);\n    this.#userAgent = getUserAgent(options.appInfo);\n    this.#features = options.features || {};\n  }\n\n  hasFlag(flag: string) {\n    return this.#features[flag] || false;\n  }\n\n  async request<TResponse = any>({ method, path, data, params }: RequestArgs, options?: RequestOptions) {\n    const requestOptions = { ...this.#options, ...options };\n\n    // compute headers out of the retry-loop, only append the telemetry later\n    const headers = this.#getHeaders(requestOptions, method);\n\n    const maxRetries = Math.max(0, requestOptions.maxRetries);\n    for (let attempt = 1; attempt <= maxRetries; attempt++) {\n      let response: AxiosResponse<TResponse, any>;\n      let error: AxiosError | null;\n      const startTime = Date.now();\n\n      this.#logger.debug(`${method} ${path}`);\n      await axios({\n        method,\n        url: path,\n        baseURL: requestOptions.host,\n        headers: {\n          ...headers,\n          ...normalizeHeaders({\n            'X-MAGICBELL-CLIENT-TELEMETRY': this.#getTelemetryHeader(),\n          }),\n        },\n        data,\n        // TODO: verify arrays are serialized in a way we support\n        params,\n        timeout: requestOptions.timeout,\n      })\n        .then((res) => {\n          response = res;\n        })\n        .catch((e) => {\n          const curl = toCurl({ method, baseURL: requestOptions.host, url: path, data, params, headers });\n          this.#logger.error(`${e.message}: ${curl}`);\n\n          error = e;\n          response = e.response;\n        });\n\n      this.#logLastRequest(response, { startTime });\n\n      if (this.#shouldRetry(response, attempt, maxRetries)) {\n        const retryAfter = Number(response.headers['retry-after']);\n        await sleep(this.#getSleepTimeInMS(attempt, retryAfter, requestOptions.maxRetryDelay));\n        continue;\n      }\n\n      if (error) {\n        throw createError({\n          name: error.name,\n          message: error.message,\n          type: error['type'],\n          status: response.status,\n          statusText: response.statusText,\n          ...(response?.data as any)?.errors?.[0],\n        });\n      }\n\n      return response.data;\n    }\n  }\n\n  #getHeaders(options: ClientOptions, method: RequestMethod) {\n    let userHmac = options.userHmac;\n    if (!userHmac && options.apiSecret && (options.userExternalId || options.userEmail)) {\n      userHmac = createHmac(options.apiSecret, options.userExternalId || options.userEmail);\n    }\n\n    const isBrowser = typeof document !== 'undefined';\n\n    return compact(\n      normalizeHeaders({\n        // can't set user-agent in the browser, see https://developer.mozilla.org/en-US/docs/Glossary/Forbidden_header_name\n        'User-Agent': isBrowser ? null : this.#userAgent,\n        'Idempotency-Key': options.idempotencyKey || this.#getDefaultIdempotencyKey(method, options.maxRetries),\n        'Accept-Version': 'v2',\n        'X-MAGICBELL-API-KEY': options.apiKey,\n        'X-MAGICBELL-API-SECRET': options.apiSecret,\n        'X-MAGICBELL-CLIENT-USER-AGENT': this.#clientUserAgent,\n        'X-MAGICBELL-USER-EMAIL': options.userEmail,\n        'X-MAGICBELL-USER-EXTERNAL-ID': options.userExternalId,\n        'X-MAGICBELL-USER-HMAC': userHmac,\n      }),\n      true,\n    );\n  }\n\n  #logLastRequest(response: AxiosResponse | undefined, { startTime }) {\n    // don't collect telemetry if the user opted out.\n    if (!this.#options.telemetry || !response?.status) return;\n\n    const headers = normalizeHeaders(response.headers);\n    this.#lastRequest.push({\n      id: headers['X-Request-Id'],\n      runtime: Number(headers['X-Runtime']),\n      duration: Date.now() - startTime,\n      status: response.status,\n    });\n  }\n\n  #getTelemetryHeader() {\n    const telemetry = this.#lastRequest.pop();\n    if (!telemetry) return null;\n    return JSON.stringify(telemetry);\n  }\n\n  #shouldRetry(response: AxiosResponse | undefined, attempt: number, maxRetries: number) {\n    // Do not retry if we are out of retries.\n    if (attempt >= maxRetries) {\n      return false;\n    }\n\n    if (!response) {\n      return true;\n    }\n\n    // Use the server's recommendation if it provides one\n    if (response.headers['should-retry']) {\n      return response.headers['should-retry'] === 'true';\n    }\n\n    if (response.status === 409 || response.status === 503) {\n      // Retry on conflict, rate limit, and availability errors.\n      return true;\n    }\n\n    // Retry on 5xx's, except POST's, which our idempotency framework would just replay as 500's again anyway.\n    if (response.status >= 500 && response.request.method !== 'POST') {\n      return true;\n    }\n\n    return false;\n  }\n\n  #getSleepTimeInMS(numRetries: number, retryAfter = null, maxDelay: number) {\n    const firstDelay = 0.5;\n\n    // Apply exponential backoff between firstDelay and maxRetryDelay\n    let sleepSeconds = Math.min(firstDelay * Math.pow(numRetries, 2), maxDelay);\n\n    // Apply some jitter by randomizing the value in the range of 75% - 100% of sleepSeconds.\n    sleepSeconds *= 0.75 * (1 + Math.random());\n\n    // But never sleep less than the base sleep seconds.\n    sleepSeconds = Math.min(Math.max(firstDelay, sleepSeconds), maxDelay);\n\n    // And never sleep less than the time the API asks us to wait, assuming it's a reasonable ask.\n    if (Number.isInteger(retryAfter) && retryAfter <= 60) {\n      sleepSeconds = Math.max(sleepSeconds, retryAfter);\n    }\n\n    return sleepSeconds * 1000;\n  }\n\n  #getDefaultIdempotencyKey(method: RequestMethod, maxRetries: number) {\n    if (method !== 'POST' || maxRetries === 0) return;\n    return `magicbell-retry-${uuid4()}`;\n  }\n}\n"],"names":["data","resolve","urlData","params"],"mappings":"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"}