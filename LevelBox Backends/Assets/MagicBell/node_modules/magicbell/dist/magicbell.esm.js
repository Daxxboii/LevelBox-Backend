/** 
 * @license magicbell v1.1.0
 *
 * Copyright (c) MagicBell Inc. and its affiliates.
 *
 * This source code is licensed under the license found in the
 * LICENSE file in the root directory of this source tree.
 */

var __defProp = Object.defineProperty;
var __defProps = Object.defineProperties;
var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp.call(b, prop))
      __defNormalProp(a, prop, b[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b)) {
      if (__propIsEnum.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));
var __publicField = (obj, key, value) => {
  __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
  return value;
};
var __accessCheck = (obj, member, msg) => {
  if (!member.has(obj))
    throw TypeError("Cannot " + msg);
};
var __privateGet = (obj, member, getter) => {
  __accessCheck(obj, member, "read from private field");
  return getter ? getter.call(obj) : member.get(obj);
};
var __privateAdd = (obj, member, value) => {
  if (member.has(obj))
    throw TypeError("Cannot add the same private member more than once");
  member instanceof WeakSet ? member.add(obj) : member.set(obj, value);
};
var __privateSet = (obj, member, value, setter) => {
  __accessCheck(obj, member, "write to private field");
  setter ? setter.call(obj, value) : member.set(obj, value);
  return value;
};
var __privateMethod = (obj, member, method) => {
  __accessCheck(obj, member, "access private method");
  return method;
};
var _userAgent, _clientUserAgent, _options, _logger, _features, _lastRequest, _getHeaders, getHeaders_fn, _logLastRequest, logLastRequest_fn, _getTelemetryHeader, getTelemetryHeader_fn, _shouldRetry, shouldRetry_fn, _getSleepTimeInMS, getSleepTimeInMS_fn, _getDefaultIdempotencyKey, getDefaultIdempotencyKey_fn;
import axios from "axios";
import crypto from "crypto";
import EventSource from "eventsource";
function createHmac(secret, data) {
  if (!secret || !data)
    return "";
  if (!crypto || !crypto.createHmac) {
    throw new Error("This method is not available in the browser. Please provide a userHmac.");
  }
  return crypto.createHmac("sha256", secret).update(data).digest("base64");
}
function getEnvInfo() {
  var _a;
  const common = {
    binding: "magicbell",
    binding_version: "1.1.0",
    publisher: "magicbell"
  };
  if (typeof process === "undefined") {
    return common;
  }
  return __spreadProps(__spreadValues({}, common), {
    runtime: ((_a = process == null ? void 0 : process.release) == null ? void 0 : _a.name) || "node",
    runtime_version: process.version,
    platform: process.platform,
    arch: process.arch
  });
}
function getAppInfoAsString(appInfo) {
  if (!(appInfo == null ? void 0 : appInfo.name))
    return "";
  return [appInfo == null ? void 0 : appInfo.name, appInfo.version && `/${appInfo.version}`, appInfo.url && ` (${appInfo.url})`].filter(Boolean).join("");
}
function getUserAgent(appInfo) {
  const env = getEnvInfo();
  return [
    `${env.binding}/${env.binding_version}`,
    "runtime" in env && `${env.runtime}/${env.runtime_version}`,
    getAppInfoAsString(appInfo)
  ].filter(Boolean).join(" ");
}
function getClientUserAgent(appInfo) {
  return JSON.stringify(__spreadProps(__spreadValues({}, getEnvInfo()), { application: appInfo }));
}
function createError(rawError) {
  for (const field of ["code", "type", "status"]) {
    switch (rawError[field]) {
      case "user_identifier_not_provided":
        return new AuthenticationError(rawError);
      case "invalid_request_error":
        return new InvalidRequestError(rawError);
      case "api_error":
        return new APIError(rawError);
      case "authentication_error":
        return new AuthenticationError(rawError);
      case "rate_limit_error":
        return new RateLimitError(rawError);
      case "idempotency_error":
        return new IdempotencyError(rawError);
      case 404:
        return new NotFoundError(rawError);
      case 422:
        return new UserInputError(rawError);
    }
  }
  return new UnknownError(rawError);
}
class BaseError extends Error {
  constructor(raw) {
    super(raw.message);
    __publicField(this, "name");
    __publicField(this, "message");
    __publicField(this, "type");
    __publicField(this, "docs_url");
    __publicField(this, "code");
    __publicField(this, "status");
    __publicField(this, "statusText");
    __publicField(this, "suggestion");
    this.type = this.constructor.name;
    this.name = "MagicBellError";
    this.code = raw.code;
    this.status = raw.status;
    this.statusText = raw.statusText;
    this.message = raw.message;
    this.suggestion = raw.suggestion;
    this.docs_url = raw.docs_url || raw.help_link;
  }
}
class InvalidRequestError extends BaseError {
}
class UserInputError extends BaseError {
}
class APIError extends BaseError {
}
class AuthenticationError extends BaseError {
}
class RateLimitError extends BaseError {
}
class IdempotencyError extends BaseError {
}
class UnknownError extends BaseError {
}
class NotFoundError extends BaseError {
}
function normalizeHeaders(headers) {
  if (!headers || typeof headers !== "object") {
    return headers;
  }
  const normalized = {};
  for (const header of Object.keys(headers)) {
    normalized[normalizeHeader(header)] = headers[header];
  }
  return normalized;
}
function normalizeHeader(header) {
  const exceptions = {
    etag: "ETag",
    magicbell: "MagicBell"
  };
  return header.split("-").map((text) => exceptions[text.toLowerCase()] || text.charAt(0).toUpperCase() + text.slice(1).toLowerCase()).join("-");
}
const colors = {
  reset: "\x1B[0m",
  magenta: "\x1B[35m",
  red: "\x1B[31m"
};
class Logger {
  constructor() {
    __publicField(this, "active", false);
  }
  debug(message) {
    if (!this.active)
      return;
    console.log(`${colors.reset}${colors.magenta}magicbell:${colors.reset} ${message}`);
  }
  error(message) {
    if (!this.active)
      return;
    console.error(`${colors.reset}${colors.red}magicbell:${colors.reset} ${message}`);
  }
}
function mask(str) {
  return str;
}
const secrets = /secret|token|key|password/i;
function isSecret(key) {
  return secrets.test(key);
}
function toCurl({ method, baseURL, url, data, headers }) {
  return [
    `curl -X ${method.toUpperCase()}`,
    `${baseURL}/${url.replace(/^\//, "")}`,
    Object.entries(headers).map(([key, value]) => `-H '${key}: ${isSecret(key) ? mask(String(value)) : value}'`).join(" "),
    data && `-d '${JSON.stringify(data)}'`
  ].join(" ");
}
const hasOwn = (obj, prop) => Object.prototype.hasOwnProperty.call(obj, prop);
function isString(value) {
  return typeof value === "string";
}
function isBoolean(value) {
  return typeof value === "boolean";
}
function isArray(value) {
  return Array.isArray(value);
}
function isStringArray(value) {
  return Array.isArray(value) && value.every((x) => typeof x === "string");
}
function isNumber(value) {
  return typeof value === "number";
}
function isObject(value) {
  return value && typeof value === "object";
}
function compact(obj, dropEmptyString = false) {
  if (typeof obj !== "object") {
    throw new Error("Argument must be an object");
  }
  const result = {};
  for (const key of Object.keys(obj)) {
    if (obj[key] == null)
      continue;
    if (dropEmptyString && obj[key] === "")
      continue;
    result[key] = obj[key];
  }
  return result;
}
function uuid4() {
  return "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g, (c) => {
    const r = Math.random() * 16 | 0;
    const v = c === "x" ? r : r & 3 | 8;
    return v.toString(16);
  });
}
async function sleep(ms) {
  return new Promise((resolve) => setTimeout(resolve, ms));
}
function joinAnd(...parts) {
  if (parts.length <= 2)
    return parts.join(" and ");
  const last = parts.slice(-1)[0];
  const others = parts.slice(0, -1);
  return [others.join(", "), last].join(", and ");
}
function joinUrlSegments(...segments) {
  return ["/", ...segments].join("/").replace(/\/+/g, "/").replace(/\/$/, "");
}
const ASYNC_ITERATOR_SYMBOL = typeof Symbol !== "undefined" && Symbol.asyncIterator ? Symbol.asyncIterator : "@@asyncIterator";
function hasMore(pageResult) {
  return hasOwn(pageResult, "current_page") && hasOwn(pageResult, "total_pages") && pageResult.current_page < pageResult.total_pages;
}
function autoPaginate(makeRequest, { data, params }) {
  const promiseCache = { currentPromise: null };
  const reverseIteration = typeof params.after !== "undefined";
  let i = 0;
  let request = makeRequest({ data, params });
  const getNextPage = (pageResult) => {
    const page = pageResult.current_page + 1;
    return makeRequest({ data, params: __spreadProps(__spreadValues({}, params), { page }) });
  };
  function iterate(pageResult) {
    const dataKey = Object.keys(pageResult).find((key) => Array.isArray(pageResult[key]));
    const data2 = pageResult[dataKey] || pageResult.data;
    if (!data2 || typeof data2.length !== "number") {
      throw Error("Unexpected: MagicBell API response does not have a well-formed response.");
    }
    if (i < data2.length) {
      const idx = reverseIteration ? data2.length - 1 - i : i;
      const value = data2[idx];
      i += 1;
      return { value, done: false };
    }
    if (hasMore(pageResult)) {
      i = 0;
      request = getNextPage(pageResult);
      return request.then(iterate);
    }
    return { value: void 0, done: true };
  }
  function asyncIteratorNext() {
    return memoizedPromise(promiseCache, (resolve, reject) => {
      return request.then(iterate).then(resolve).catch(reject);
    });
  }
  const forEach = makeForEach(asyncIteratorNext);
  const toArray = makeToArray(forEach);
  const autoPaginationMethods = {
    forEach,
    toArray,
    next: asyncIteratorNext,
    return: () => ({}),
    [ASYNC_ITERATOR_SYMBOL]: () => {
      return autoPaginationMethods;
    }
  };
  return Object.assign(request, autoPaginationMethods);
}
function memoizedPromise(promiseCache, cb) {
  if (promiseCache.currentPromise) {
    return promiseCache.currentPromise;
  }
  promiseCache.currentPromise = new Promise(cb).then((ret) => {
    promiseCache.currentPromise = void 0;
    return ret;
  });
  return promiseCache.currentPromise;
}
function makeForEach(asyncIteratorNext, onDoneCallback) {
  return function forEach(onItem) {
    return new Promise((resolve, reject) => {
      let idx = 0;
      function handleIteration(iterResult) {
        if (iterResult.done) {
          resolve();
          return;
        }
        const item = iterResult.value;
        return new Promise((resolve2) => {
          resolve2(onItem(item, idx));
        }).then((shouldContinue) => {
          if (shouldContinue === false) {
            onDoneCallback == null ? void 0 : onDoneCallback();
            return handleIteration({ done: true });
          } else {
            idx++;
            return asyncIteratorNext().then(handleIteration);
          }
        });
      }
      asyncIteratorNext().then(handleIteration).catch(reject);
    });
  };
}
function makeToArray(forEach) {
  return function toArray(options) {
    const limit = options == null ? void 0 : options.limit;
    if (!limit) {
      throw Error("You must pass a `limit` option to toArray, e.g., `toArray({ limit: 1000 });`.");
    }
    if (limit > 1e4) {
      throw Error(
        "You cannot specify a limit of more than 10,000 items to fetch in `toArray`; use `forEach` to iterate through longer lists."
      );
    }
    return new Promise((resolve, reject) => {
      const items = [];
      forEach((item) => {
        items.push(item);
        if (items.length >= limit) {
          return false;
        }
      }).then(() => {
        resolve(items);
      }).catch(reject);
    });
  };
}
function createListener(client, args = {}) {
  let eventSource;
  let channels;
  let lastEvent;
  let configPromise;
  const messages = [];
  let resolve;
  const pushMessage = (p) => {
    messages.push(p);
    if (resolve) {
      resolve();
      resolve = null;
    }
  };
  async function connect(options) {
    if (!channels && !configPromise) {
      configPromise = client.request({ method: "GET", path: "/config" }, options).then((x) => channels = x.ws.channel);
    }
    const auth = await client.request({ method: "POST", path: "/ws/auth" }, options);
    const { token } = await axios.post(`https://rest.ably.io/keys/${auth.keyName}/requestToken`, auth).then((x) => x.data);
    await configPromise;
    const sseHost = args.sseHost || "https://realtime.ably.io";
    const url = new URL("sse", sseHost);
    url.searchParams.append("v", "1.1");
    url.searchParams.append("accessToken", token);
    url.searchParams.append("channels", channels);
    url.searchParams.append("heartbeats", "true");
    if (lastEvent) {
      url.searchParams.append("lastEvent", lastEvent);
    }
    if (eventSource) {
      eventSource.close();
    }
    eventSource = new EventSource(url.toString());
    eventSource.onmessage = (event) => {
      if (event.origin !== sseHost)
        return;
      lastEvent = event.lastEventId;
      if (!("data" in event))
        return;
      const message = JSON.parse(event.data);
      if (message.type === "close") {
        return pushMessage({ value: null, done: true });
      }
      message.data = message.encoding === "json" ? JSON.parse(message.data) : message.data;
      pushMessage({ value: message, done: false });
    };
    eventSource.onerror = (msg) => {
      const err = "data" in msg ? JSON.parse(msg.data) : {};
      const isTokenErr = err.code >= 40140 && err.code < 40150;
      if (isTokenErr) {
        eventSource.close();
        connect(options);
      } else if (/invalid channel id/i.test(err.message)) {
        eventSource.close();
        pushMessage({ value: null, done: true });
      } else {
        console.log("err", msg);
      }
    };
  }
  function listen(options) {
    void connect(options);
    const asyncIteratorNext = async () => {
      if (!messages.length)
        await new Promise((r) => resolve = r);
      const event = messages.pop();
      if (event.done && eventSource)
        eventSource.close();
      return event;
    };
    const dispose = () => {
      eventSource.close();
      return { done: true, value: void 0 };
    };
    const forEach = makeForEach(asyncIteratorNext, dispose);
    const autoPaginationMethods = {
      forEach,
      next: asyncIteratorNext,
      return: dispose,
      [ASYNC_ITERATOR_SYMBOL]: () => {
        return autoPaginationMethods;
      }
    };
    return autoPaginationMethods;
  }
  return listen;
}
const optionValidators = {
  host: isString,
  maxRetryDelay: isNumber,
  timeout: isNumber,
  apiKey: isString,
  maxRetries: isNumber,
  userEmail: isString,
  userExternalId: isString,
  userHmac: isString,
  idempotencyKey: isString,
  telemetry: isBoolean,
  apiSecret: isString,
  appInfo: isObject,
  debug: isBoolean,
  features: isObject
};
function isOptionsHash(object) {
  var _a;
  if (!isObject(object))
    return false;
  for (const key of Object.keys(object)) {
    if (!((_a = optionValidators[key]) == null ? void 0 : _a.call(optionValidators, object[key])))
      return false;
  }
  return true;
}
const queryParamValidators = {
  archived: isBoolean,
  read: isBoolean,
  seen: isBoolean,
  categories: (value) => isString(value) || isStringArray(value),
  topics: (value) => isString(value) || isStringArray(value)
};
function isForcedQueryParams(object) {
  var _a;
  if (!isObject(object))
    return false;
  for (const key of Object.keys(object)) {
    if (!((_a = queryParamValidators[key]) == null ? void 0 : _a.call(queryParamValidators, object[key])))
      return false;
  }
  return true;
}
function getUrl(path, params, options = { encode: true }) {
  return path.replace(
    /{([\s\S]+?)}/g,
    ($0, $1) => options.encode ? encodeURIComponent(params[$1] || "") : params[$1] || ""
  );
}
function extractUrlParams(path) {
  const params = path.match(/{\w+}/g) || [];
  return (params || []).map((param) => param.replace(/[{}]/g, ""));
}
function getDataFromArgs(args) {
  if (!isArray(args) || !isObject(args[0]))
    return {};
  if (isOptionsHash(args[0]))
    return {};
  return args.shift();
}
function getOptionsFromArgs(args) {
  if (!isArray(args) || args.length === 0)
    return {};
  const arg = args[args.length - 1];
  if (!isOptionsHash(arg))
    return {};
  return __spreadValues({}, args.pop());
}
function normalizeArgs({
  path,
  method,
  args
}) {
  const argsCopy = [...args].filter((x) => x !== void 0);
  const urlParams = extractUrlParams(path);
  const urlData = urlParams.reduce((urlData2, param) => {
    const arg = argsCopy.shift();
    if (typeof arg !== "string") {
      throw new Error(
        `MagicBell: Argument "${param}" must be a string, but got ${typeof arg}: ${JSON.stringify(
          arg
        )} (on API request to \`${method} ${path}\`)`
      );
    }
    urlData2[param] = arg;
    return urlData2;
  }, {});
  const url = getUrl(path, urlData, { encode: false });
  const dataFromArgs = getDataFromArgs(argsCopy);
  const options = getOptionsFromArgs(argsCopy);
  if (argsCopy.filter((x) => x != null).length) {
    throw new Error(
      `MagicBell: Unknown arguments (${JSON.stringify(argsCopy)}). (on API request to \`${method} ${url}\`)`
    );
  }
  let dataInQuery = method === "GET";
  if (method === "POST" && isForcedQueryParams(dataFromArgs)) {
    dataInQuery = true;
  }
  const data = dataInQuery ? {} : dataFromArgs;
  const params = dataInQuery ? dataFromArgs : {};
  return { path: url, data, params, options };
}
function isEmptyPayload(data) {
  if (!data)
    return true;
  if (Array.isArray(data))
    return data.length === 0;
  if (typeof data === "object")
    return Object.keys(data).length === 0;
  return false;
}
class Resource {
  constructor(client) {
    __publicField(this, "path");
    __publicField(this, "entity");
    __publicField(this, "client");
    this.client = client;
  }
  request({ method, paged, path: tplPath }, ...args) {
    const { path, data, params, options } = normalizeArgs({
      path: joinUrlSegments(this.path, tplPath),
      method,
      args
    });
    const makeRequest = ({ data: data2, params: params2 }) => {
      const entity = this.entity || this.path;
      data2 = isEmptyPayload(data2) ? void 0 : { [entity]: data2 };
      params2 = isEmptyPayload(params2) ? void 0 : params2;
      return this.client.request({ method, path, data: data2, params: params2 }, options).then((response) => response[entity] || response);
    };
    if (paged) {
      return autoPaginate(makeRequest, {
        data,
        params
      });
    }
    return makeRequest({ data, params });
  }
  assertFeatureFlag(flag) {
    if (!this.client.hasFlag(flag)) {
      throw new Error(`This is a beta feature, please enable it by providing the "${flag}" feature flag.`);
    }
  }
}
class Imports extends Resource {
  constructor() {
    super(...arguments);
    __publicField(this, "path", "imports");
    __publicField(this, "entity", "import");
  }
  create(dataOrOptions, options) {
    return this.request(
      {
        method: "POST"
      },
      dataOrOptions,
      options
    );
  }
  get(importId, options) {
    return this.request(
      {
        method: "GET",
        path: "{import_id}"
      },
      importId,
      options
    );
  }
}
class NotificationPreferences extends Resource {
  constructor() {
    super(...arguments);
    __publicField(this, "path", "notification_preferences");
    __publicField(this, "entity", "notification_preferences");
  }
  get(options) {
    return this.request(
      {
        method: "GET"
      },
      options
    );
  }
  update(dataOrOptions, options) {
    return this.request(
      {
        method: "PUT"
      },
      dataOrOptions,
      options
    );
  }
}
class Notifications extends Resource {
  constructor() {
    super(...arguments);
    __publicField(this, "path", "notifications");
    __publicField(this, "entity", "notification");
  }
  create(data, options) {
    return this.request(
      {
        method: "POST"
      },
      data,
      options
    );
  }
  list(dataOrOptions, options) {
    return this.request(
      {
        method: "GET",
        paged: true
      },
      dataOrOptions,
      options
    );
  }
  get(notificationId, options) {
    return this.request(
      {
        method: "GET",
        path: "{notification_id}"
      },
      notificationId,
      options
    );
  }
  delete(notificationId, options) {
    return this.request(
      {
        method: "DELETE",
        path: "{notification_id}"
      },
      notificationId,
      options
    );
  }
  markAsRead(notificationId, options) {
    return this.request(
      {
        method: "POST",
        path: "{notification_id}/read"
      },
      notificationId,
      options
    );
  }
  markAsUnread(notificationId, options) {
    return this.request(
      {
        method: "POST",
        path: "{notification_id}/unread"
      },
      notificationId,
      options
    );
  }
  archive(notificationId, options) {
    return this.request(
      {
        method: "POST",
        path: "{notification_id}/archive"
      },
      notificationId,
      options
    );
  }
  unarchive(notificationId, options) {
    return this.request(
      {
        method: "DELETE",
        path: "{notification_id}/archive"
      },
      notificationId,
      options
    );
  }
  markAllRead(dataOrOptions, options) {
    return this.request(
      {
        method: "POST",
        path: "read"
      },
      dataOrOptions,
      options
    );
  }
  markAllSeen(dataOrOptions, options) {
    return this.request(
      {
        method: "POST",
        path: "seen"
      },
      dataOrOptions,
      options
    );
  }
}
class PushSubscriptions extends Resource {
  constructor() {
    super(...arguments);
    __publicField(this, "path", "push_subscriptions");
    __publicField(this, "entity", "push_subscription");
  }
  create(data, options) {
    this.assertFeatureFlag("push-subscriptions-create");
    return this.request(
      {
        method: "POST"
      },
      data,
      options
    );
  }
  delete(deviceToken, options) {
    this.assertFeatureFlag("push-subscriptions-delete");
    return this.request(
      {
        method: "DELETE",
        path: "{device_token}"
      },
      deviceToken,
      options
    );
  }
}
class Subscriptions extends Resource {
  constructor() {
    super(...arguments);
    __publicField(this, "path", "subscriptions");
    __publicField(this, "entity", "subscription");
  }
  list(options) {
    return this.request(
      {
        method: "GET",
        paged: true
      },
      options
    );
  }
  create(data, options) {
    return this.request(
      {
        method: "POST"
      },
      data,
      options
    );
  }
  unsubscribe(topic, data, options) {
    return this.request(
      {
        method: "POST",
        path: "{topic}/unsubscribe"
      },
      topic,
      data,
      options
    );
  }
  get(topic, options) {
    return this.request(
      {
        method: "GET",
        path: "{topic}"
      },
      topic,
      options
    );
  }
  delete(topic, dataOrOptions, options) {
    return this.request(
      {
        method: "DELETE",
        path: "{topic}"
      },
      topic,
      dataOrOptions,
      options
    );
  }
}
class Users extends Resource {
  constructor() {
    super(...arguments);
    __publicField(this, "path", "users");
    __publicField(this, "entity", "user");
  }
  create(dataOrOptions, options) {
    return this.request(
      {
        method: "POST"
      },
      dataOrOptions,
      options
    );
  }
  update(userId, dataOrOptions, options) {
    return this.request(
      {
        method: "PUT",
        path: "{user_id}"
      },
      userId,
      dataOrOptions,
      options
    );
  }
  delete(userId, options) {
    return this.request(
      {
        method: "DELETE",
        path: "{user_id}"
      },
      userId,
      options
    );
  }
  updateByEmail(userEmail, dataOrOptions, options) {
    return this.request(
      {
        method: "PUT",
        path: "email:{user_email}"
      },
      userEmail,
      dataOrOptions,
      options
    );
  }
  deleteByEmail(userEmail, options) {
    return this.request(
      {
        method: "DELETE",
        path: "email:{user_email}"
      },
      userEmail,
      options
    );
  }
  updateByExternalId(externalId, dataOrOptions, options) {
    return this.request(
      {
        method: "PUT",
        path: "external_id:{external_id}"
      },
      externalId,
      dataOrOptions,
      options
    );
  }
  deleteByExternalId(externalId, options) {
    return this.request(
      {
        method: "DELETE",
        path: "external_id:{external_id}"
      },
      externalId,
      options
    );
  }
}
if (typeof XMLHttpRequest !== "function") {
  axios.defaults.adapter = require("axios/lib/adapters/http");
}
const DEFAULT_OPTIONS = {
  host: "https://api.magicbell.com",
  timeout: 3e4,
  maxRetries: 3,
  maxRetryDelay: 60,
  telemetry: true
};
class Client {
  constructor(options) {
    __privateAdd(this, _getHeaders);
    __privateAdd(this, _logLastRequest);
    __privateAdd(this, _getTelemetryHeader);
    __privateAdd(this, _shouldRetry);
    __privateAdd(this, _getSleepTimeInMS);
    __privateAdd(this, _getDefaultIdempotencyKey);
    __privateAdd(this, _userAgent, void 0);
    __privateAdd(this, _clientUserAgent, void 0);
    __privateAdd(this, _options, void 0);
    __privateAdd(this, _logger, new Logger());
    __privateAdd(this, _features, {});
    __privateAdd(this, _lastRequest, []);
    __publicField(this, "listen", createListener(this));
    __publicField(this, "imports", new Imports(this));
    __publicField(this, "notificationPreferences", new NotificationPreferences(this));
    __publicField(this, "notifications", new Notifications(this));
    __publicField(this, "pushSubscriptions", new PushSubscriptions(this));
    __publicField(this, "subscriptions", new Subscriptions(this));
    __publicField(this, "users", new Users(this));
    const missingOptions = ["apiKey"].filter((x) => !hasOwn(options, x));
    if (missingOptions.length) {
      throw new Error(
        `You haven't provided all required options, please provide ${joinAnd(...missingOptions)} to Client(options)`
      );
    }
    if (!isOptionsHash(options)) {
      throw new Error(`You have provided invalid options. Please check your client options.`);
    }
    __privateSet(this, _options, Object.assign({}, DEFAULT_OPTIONS, options));
    __privateGet(this, _logger).active = Boolean(__privateGet(this, _options).debug);
    __privateSet(this, _clientUserAgent, getClientUserAgent(options.appInfo));
    __privateSet(this, _userAgent, getUserAgent(options.appInfo));
    __privateSet(this, _features, options.features || {});
  }
  hasFlag(flag) {
    return __privateGet(this, _features)[flag] || false;
  }
  async request({ method, path, data, params }, options) {
    var _a, _b;
    const requestOptions = __spreadValues(__spreadValues({}, __privateGet(this, _options)), options);
    const headers = __privateMethod(this, _getHeaders, getHeaders_fn).call(this, requestOptions, method);
    const maxRetries = Math.max(0, requestOptions.maxRetries);
    for (let attempt = 1; attempt <= maxRetries; attempt++) {
      let response;
      let error;
      const startTime = Date.now();
      __privateGet(this, _logger).debug(`${method} ${path}`);
      await axios({
        method,
        url: path,
        baseURL: requestOptions.host,
        headers: __spreadValues(__spreadValues({}, headers), normalizeHeaders({
          "X-MAGICBELL-CLIENT-TELEMETRY": __privateMethod(this, _getTelemetryHeader, getTelemetryHeader_fn).call(this)
        })),
        data,
        params,
        timeout: requestOptions.timeout
      }).then((res) => {
        response = res;
      }).catch((e) => {
        const curl = toCurl({ method, baseURL: requestOptions.host, url: path, data, params, headers });
        __privateGet(this, _logger).error(`${e.message}: ${curl}`);
        error = e;
        response = e.response;
      });
      __privateMethod(this, _logLastRequest, logLastRequest_fn).call(this, response, { startTime });
      if (__privateMethod(this, _shouldRetry, shouldRetry_fn).call(this, response, attempt, maxRetries)) {
        const retryAfter = Number(response.headers["retry-after"]);
        await sleep(__privateMethod(this, _getSleepTimeInMS, getSleepTimeInMS_fn).call(this, attempt, retryAfter, requestOptions.maxRetryDelay));
        continue;
      }
      if (error) {
        throw createError(__spreadValues({
          name: error.name,
          message: error.message,
          type: error["type"],
          status: response.status,
          statusText: response.statusText
        }, (_b = (_a = response == null ? void 0 : response.data) == null ? void 0 : _a.errors) == null ? void 0 : _b[0]));
      }
      return response.data;
    }
  }
}
_userAgent = new WeakMap();
_clientUserAgent = new WeakMap();
_options = new WeakMap();
_logger = new WeakMap();
_features = new WeakMap();
_lastRequest = new WeakMap();
_getHeaders = new WeakSet();
getHeaders_fn = function(options, method) {
  let userHmac = options.userHmac;
  if (!userHmac && options.apiSecret && (options.userExternalId || options.userEmail)) {
    userHmac = createHmac(options.apiSecret, options.userExternalId || options.userEmail);
  }
  const isBrowser = typeof document !== "undefined";
  return compact(
    normalizeHeaders({
      "User-Agent": isBrowser ? null : __privateGet(this, _userAgent),
      "Idempotency-Key": options.idempotencyKey || __privateMethod(this, _getDefaultIdempotencyKey, getDefaultIdempotencyKey_fn).call(this, method, options.maxRetries),
      "Accept-Version": "v2",
      "X-MAGICBELL-API-KEY": options.apiKey,
      "X-MAGICBELL-API-SECRET": options.apiSecret,
      "X-MAGICBELL-CLIENT-USER-AGENT": __privateGet(this, _clientUserAgent),
      "X-MAGICBELL-USER-EMAIL": options.userEmail,
      "X-MAGICBELL-USER-EXTERNAL-ID": options.userExternalId,
      "X-MAGICBELL-USER-HMAC": userHmac
    }),
    true
  );
};
_logLastRequest = new WeakSet();
logLastRequest_fn = function(response, { startTime }) {
  if (!__privateGet(this, _options).telemetry || !(response == null ? void 0 : response.status))
    return;
  const headers = normalizeHeaders(response.headers);
  __privateGet(this, _lastRequest).push({
    id: headers["X-Request-Id"],
    runtime: Number(headers["X-Runtime"]),
    duration: Date.now() - startTime,
    status: response.status
  });
};
_getTelemetryHeader = new WeakSet();
getTelemetryHeader_fn = function() {
  const telemetry = __privateGet(this, _lastRequest).pop();
  if (!telemetry)
    return null;
  return JSON.stringify(telemetry);
};
_shouldRetry = new WeakSet();
shouldRetry_fn = function(response, attempt, maxRetries) {
  if (attempt >= maxRetries) {
    return false;
  }
  if (!response) {
    return true;
  }
  if (response.headers["should-retry"]) {
    return response.headers["should-retry"] === "true";
  }
  if (response.status === 409 || response.status === 503) {
    return true;
  }
  if (response.status >= 500 && response.request.method !== "POST") {
    return true;
  }
  return false;
};
_getSleepTimeInMS = new WeakSet();
getSleepTimeInMS_fn = function(numRetries, retryAfter = null, maxDelay) {
  const firstDelay = 0.5;
  let sleepSeconds = Math.min(firstDelay * Math.pow(numRetries, 2), maxDelay);
  sleepSeconds *= 0.75 * (1 + Math.random());
  sleepSeconds = Math.min(Math.max(firstDelay, sleepSeconds), maxDelay);
  if (Number.isInteger(retryAfter) && retryAfter <= 60) {
    sleepSeconds = Math.max(sleepSeconds, retryAfter);
  }
  return sleepSeconds * 1e3;
};
_getDefaultIdempotencyKey = new WeakSet();
getDefaultIdempotencyKey_fn = function(method, maxRetries) {
  if (method !== "POST" || maxRetries === 0)
    return;
  return `magicbell-retry-${uuid4()}`;
};
export {
  Client,
  createHmac,
  Client as default
};
//# sourceMappingURL=magicbell.esm.js.map
