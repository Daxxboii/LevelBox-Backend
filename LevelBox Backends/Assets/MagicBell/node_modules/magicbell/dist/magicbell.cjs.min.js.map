{"version":3,"file":"magicbell.cjs.min.js","sources":["../src/lib/crypto.ts","../src/lib/env.ts","../src/lib/error.ts","../src/lib/headers.ts","../src/lib/log.ts","../src/lib/utils.ts","../src/paginate.ts","../src/listen.ts","../src/options.ts","../src/method.ts","../src/resource.ts","../src/resources/imports.ts","../src/resources/notification-preferences.ts","../src/resources/notifications.ts","../src/resources/push-subscriptions.ts","../src/resources/subscriptions.ts","../src/resources/users.ts","../src/client.ts"],"sourcesContent":["import crypto from 'crypto';\n\nexport function createHmac(secret: string, data: string) {\n  if (!secret || !data) return '';\n\n  if (!crypto || !crypto.createHmac) {\n    throw new Error('This method is not available in the browser. Please provide a userHmac.');\n  }\n\n  return crypto.createHmac('sha256', secret).update(data).digest('base64');\n}\n","import { ClientOptions } from '../types';\n\nexport function getEnvInfo() {\n  const common = {\n    binding: __PACKAGE_NAME__,\n    binding_version: __PACKAGE_VERSION__,\n    publisher: 'magicbell',\n  };\n\n  if (typeof process === 'undefined') {\n    return common;\n  }\n\n  return {\n    ...common,\n    runtime: process?.release?.name || 'node',\n    runtime_version: process.version,\n    platform: process.platform,\n    arch: process.arch,\n  };\n}\n\nfunction getAppInfoAsString(appInfo?: ClientOptions['appInfo']) {\n  if (!appInfo?.name) return '';\n\n  return [appInfo?.name, appInfo.version && `/${appInfo.version}`, appInfo.url && ` (${appInfo.url})`]\n    .filter(Boolean)\n    .join('');\n}\n\nexport function getUserAgent(appInfo?: ClientOptions['appInfo']) {\n  const env = getEnvInfo();\n\n  return [\n    `${env.binding}/${env.binding_version}`,\n    'runtime' in env && `${env.runtime}/${env.runtime_version}`,\n    getAppInfoAsString(appInfo),\n  ]\n    .filter(Boolean)\n    .join(' ');\n}\n\nexport function getClientUserAgent(appInfo?: ClientOptions['appInfo']) {\n  return JSON.stringify({ ...getEnvInfo(), application: appInfo });\n}\n","'use strict';\n\n// TODO: sync & cleanup\nexport function createError(rawError: ErrorConfig) {\n  for (const field of ['code', 'type', 'status']) {\n    switch (rawError[field]) {\n      case 'user_identifier_not_provided':\n        return new AuthenticationError(rawError);\n      case 'invalid_request_error':\n        return new InvalidRequestError(rawError);\n      case 'api_error':\n        return new APIError(rawError);\n      case 'authentication_error':\n        return new AuthenticationError(rawError);\n      case 'rate_limit_error':\n        return new RateLimitError(rawError);\n      case 'idempotency_error':\n        return new IdempotencyError(rawError);\n      case 404:\n        return new NotFoundError(rawError);\n      case 422:\n        return new UserInputError(rawError);\n    }\n  }\n\n  return new UnknownError(rawError);\n}\n\ntype ErrorConfig = {\n  name: string;\n  type?: string;\n  code?: string;\n  docs_url?: string;\n  help_link?: string;\n  status?: number;\n  statusText?: string;\n  message: string;\n  suggestion?: string;\n};\n\n/**\n * BaseError is the base error from which all other more specific errors derive.\n * Specifically for errors returned from REST API.\n */\nclass BaseError extends Error {\n  name: string;\n  message: string;\n  type?: string;\n  docs_url?: string;\n  code?: string;\n  status?: number;\n  statusText?: string;\n  suggestion?: string;\n\n  constructor(raw: ErrorConfig) {\n    super(raw.message);\n    this.type = this.constructor.name;\n    this.name = 'MagicBellError';\n    this.code = raw.code;\n    this.status = raw.status;\n    this.statusText = raw.statusText;\n    this.message = raw.message;\n    this.suggestion = raw.suggestion;\n    this.docs_url = raw.docs_url || raw.help_link;\n  }\n}\n\nexport class InvalidRequestError extends BaseError {}\nexport class UserInputError extends BaseError {}\nexport class APIError extends BaseError {}\nexport class AuthenticationError extends BaseError {}\nexport class PermissionError extends BaseError {}\nexport class RateLimitError extends BaseError {}\nexport class ConnectionError extends BaseError {}\nexport class IdempotencyError extends BaseError {}\nexport class UnknownError extends BaseError {}\nexport class NotFoundError extends BaseError {}\n","/**\n * Normalize standard HTTP Headers:\n * {'foo-bar': 'hi'}\n * becomes\n * {'Foo-Bar': 'hi'}\n */\nexport function normalizeHeaders(headers: Record<string, string>) {\n  if (!headers || typeof headers !== 'object') {\n    return headers;\n  }\n\n  const normalized = {};\n  for (const header of Object.keys(headers)) {\n    normalized[normalizeHeader(header)] = headers[header];\n  }\n\n  return normalized;\n}\n\n/**\n * Stolen from https://github.com/marten-de-vries/header-case-normalizer/blob/master/index.js#L36-L41\n * without the exceptions which are irrelevant to us.\n */\nfunction normalizeHeader(header) {\n  const exceptions = {\n    etag: 'ETag',\n    magicbell: 'MagicBell',\n  };\n\n  return header\n    .split('-')\n    .map((text) => exceptions[text.toLowerCase()] || text.charAt(0).toUpperCase() + text.slice(1).toLowerCase())\n    .join('-');\n}\n","import { AxiosRequestConfig } from 'axios';\n\nconst colors = {\n  reset: '\\x1b[0m',\n  magenta: '\\x1b[35m',\n  red: '\\x1b[31m',\n};\n\nexport function emitWarning(message) {\n  if (typeof process.emitWarning !== 'function') {\n    return console.warn(`magicbell: ${message}`);\n  }\n\n  return process.emitWarning(message, 'magicbell');\n}\n\nexport class Logger {\n  active = false;\n\n  debug(message) {\n    if (!this.active) return;\n\n    // eslint-disable-next-line no-console\n    console.log(`${colors.reset}${colors.magenta}magicbell:${colors.reset} ${message}`);\n  }\n\n  error(message) {\n    if (!this.active) return;\n\n    // eslint-disable-next-line no-console\n    console.error(`${colors.reset}${colors.red}magicbell:${colors.reset} ${message}`);\n  }\n}\n\nfunction mask(str: string) {\n  if (__DEV__) return str;\n  return `${str.slice(0, 4)}â€¦${str.slice(-4)}`;\n}\n\nconst secrets = /secret|token|key|password/i;\nfunction isSecret(key: string) {\n  return secrets.test(key);\n}\n\nexport function toCurl({ method, baseURL, url, data, headers }: AxiosRequestConfig) {\n  return [\n    `curl -X ${method.toUpperCase()}`,\n    `${baseURL}/${url.replace(/^\\//, '')}`,\n    Object.entries(headers)\n      .map(([key, value]) => `-H '${key}: ${isSecret(key) ? mask(String(value)) : value}'`)\n      .join(' '),\n    data && `-d '${JSON.stringify(data)}'`,\n  ].join(' ');\n}\n","export const hasOwn = (obj, prop) => Object.prototype.hasOwnProperty.call(obj, prop);\n\nexport const compose = <R>(fn1: (a: R) => R, ...fns: Array<(a: R) => R>) =>\n  fns.reduce((prevFn, nextFn) => (value) => prevFn(nextFn(value)), fn1);\n\nexport function isString(value) {\n  return typeof value === 'string';\n}\n\nexport function isBoolean(value) {\n  return typeof value === 'boolean';\n}\n\nexport function isArray(value) {\n  return Array.isArray(value);\n}\n\nexport function isStringArray(value) {\n  return Array.isArray(value) && value.every((x) => typeof x === 'string');\n}\n\nexport function isNumber(value) {\n  return typeof value === 'number';\n}\n\nexport function isObject(value) {\n  return value && typeof value === 'object';\n}\n\nexport function compact(obj: Record<string, unknown>, dropEmptyString = false) {\n  if (typeof obj !== 'object') {\n    throw new Error('Argument must be an object');\n  }\n\n  const result = {};\n  for (const key of Object.keys(obj)) {\n    if (obj[key] == null) continue;\n    if (dropEmptyString && obj[key] === '') continue;\n    result[key] = obj[key];\n  }\n\n  return result;\n}\n\nexport function uuid4() {\n  // TODO: should be upgradable to crypto.randomUUID(), introduced by node v14\n  return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, (c) => {\n    const r = (Math.random() * 16) | 0;\n    const v = c === 'x' ? r : (r & 0x3) | 0x8;\n    return v.toString(16);\n  });\n}\n\nexport async function sleep(ms: number) {\n  return new Promise((resolve) => setTimeout(resolve, ms));\n}\n\nexport function joinAnd(...parts) {\n  if (parts.length <= 2) return parts.join(' and ');\n\n  const last = parts.slice(-1)[0];\n  const others = parts.slice(0, -1);\n  return [others.join(', '), last].join(', and ');\n}\n\nexport function joinOr(...parts) {\n  if (parts.length <= 2) return parts.join(' or ');\n\n  const last = parts.slice(-1)[0];\n  const others = parts.slice(0, -1);\n  return [others.join(', '), last].join(', or ');\n}\n\nexport function joinUrlSegments(...segments) {\n  return ['/', ...segments].join('/').replace(/\\/+/g, '/').replace(/\\/$/, '');\n}\n","import { hasOwn } from './lib/utils';\n\nexport const ASYNC_ITERATOR_SYMBOL =\n  typeof Symbol !== 'undefined' && Symbol.asyncIterator ? Symbol.asyncIterator : '@@asyncIterator';\n\nfunction hasMore(pageResult) {\n  return (\n    hasOwn(pageResult, 'current_page') &&\n    hasOwn(pageResult, 'total_pages') &&\n    pageResult.current_page < pageResult.total_pages\n  );\n}\n\nexport function autoPaginate(makeRequest, { data, params }) {\n  const promiseCache = { currentPromise: null };\n  const reverseIteration = typeof params.after !== 'undefined';\n\n  let i = 0;\n  let request = makeRequest({ data, params });\n\n  const getNextPage = (pageResult) => {\n    const page = pageResult.current_page + 1;\n    return makeRequest({ data, params: { ...params, page } });\n  };\n\n  function iterate(pageResult) {\n    const dataKey = Object.keys(pageResult).find((key) => Array.isArray(pageResult[key]));\n    const data = pageResult[dataKey] || pageResult.data;\n\n    if (!data || typeof data.length !== 'number') {\n      throw Error('Unexpected: MagicBell API response does not have a well-formed response.');\n    }\n\n    if (i < data.length) {\n      const idx = reverseIteration ? data.length - 1 - i : i;\n      const value = data[idx];\n      i += 1;\n\n      return { value, done: false };\n    }\n\n    if (hasMore(pageResult)) {\n      // Reset counter, request next page, and recurse.\n      i = 0;\n      request = getNextPage(pageResult);\n      return request.then(iterate);\n    }\n\n    return { value: undefined, done: true };\n  }\n\n  function asyncIteratorNext() {\n    return memoizedPromise(promiseCache, (resolve, reject) => {\n      return request.then(iterate).then(resolve).catch(reject);\n    });\n  }\n\n  const forEach = makeForEach(asyncIteratorNext);\n  const toArray = makeToArray(forEach);\n\n  const autoPaginationMethods = {\n    forEach,\n    toArray,\n\n    next: asyncIteratorNext,\n    return: () => ({}),\n    [ASYNC_ITERATOR_SYMBOL]: () => {\n      return autoPaginationMethods;\n    },\n  };\n\n  return Object.assign(request, autoPaginationMethods);\n}\n\n/**\n * If a user calls `.next()` multiple times in parallel,\n * return the same result until something has resolved\n * to prevent page-turning race conditions.\n */\nfunction memoizedPromise(promiseCache, cb) {\n  if (promiseCache.currentPromise) {\n    return promiseCache.currentPromise;\n  }\n  promiseCache.currentPromise = new Promise(cb).then((ret) => {\n    promiseCache.currentPromise = undefined;\n    return ret;\n  });\n  return promiseCache.currentPromise;\n}\n\nexport function makeForEach(asyncIteratorNext, onDoneCallback?: () => void) {\n  return function forEach(onItem) {\n    return new Promise<void>((resolve, reject) => {\n      let idx = 0;\n      function handleIteration(iterResult) {\n        if (iterResult.done) {\n          resolve();\n          return;\n        }\n\n        const item = iterResult.value;\n        return new Promise((resolve) => {\n          resolve(onItem(item, idx));\n        }).then((shouldContinue) => {\n          if (shouldContinue === false) {\n            onDoneCallback?.();\n            return handleIteration({ done: true });\n          } else {\n            idx++;\n            return asyncIteratorNext().then(handleIteration);\n          }\n        });\n      }\n\n      asyncIteratorNext().then(handleIteration).catch(reject);\n    });\n  };\n}\n\nfunction makeToArray(forEach) {\n  return function toArray(options) {\n    const limit = options?.limit;\n    if (!limit) {\n      throw Error('You must pass a `limit` option to toArray, e.g., `toArray({ limit: 1000 });`.');\n    }\n\n    if (limit > 10_000) {\n      throw Error(\n        'You cannot specify a limit of more than 10,000 items to fetch in `toArray`; use `forEach` to iterate through longer lists.',\n      );\n    }\n\n    return new Promise((resolve, reject) => {\n      const items = [];\n      forEach((item) => {\n        items.push(item);\n        if (items.length >= limit) {\n          return false;\n        }\n      })\n        .then(() => {\n          resolve(items);\n        })\n        .catch(reject);\n    });\n  };\n}\n","import axios from 'axios';\nimport EventSource from 'eventsource';\n\nimport { Client } from './client';\nimport { ASYNC_ITERATOR_SYMBOL, makeForEach } from './paginate';\nimport { RequestOptions } from './types';\n\ntype AuthResponse = {\n  keyName: string;\n  timestamp: number;\n  nonce: string;\n  ttl: number;\n  mac: string;\n};\n\ntype TokenResponse = {\n  token: string;\n  keyName: string;\n  issued: number;\n  expires: number;\n  capability: string;\n  userClaims: string;\n};\n\ntype Event = {\n  id: string;\n  timestamp: number;\n  encoding: string;\n  channel: string;\n} & (\n  | { name: 'notifications/new'; data: { id: string } }\n  | { name: 'notifications/read'; data: { id: string; client_id: string } }\n  | { name: 'notifications/read/all'; data: { client_id: string } }\n  | { name: 'notifications/seen/all'; data: { client_id: string } }\n  | { name: 'notifications/unread'; data: { id: string; client_id: string } }\n  | { name: 'notifications/delete'; data: { id: string; client_id: string | null } }\n);\n\ntype IterableEventSource<TNode> = {\n  [Symbol.asyncIterator](): Iterator<TNode>;\n  forEach(cb: (node: TNode, index: number) => void | boolean | Promise<void | boolean>): Promise<void>;\n};\n\nexport type Listener = (options?: RequestOptions) => IterableEventSource<Event>;\n\nexport function createListener(client: InstanceType<typeof Client>, args: { sseHost?: string } = {}): Listener {\n  let eventSource: EventSource;\n  let channels: string;\n  let lastEvent: string;\n  let configPromise;\n\n  const messages: { value: Event; done: boolean }[] = [];\n  let resolve;\n\n  const pushMessage = (p) => {\n    messages.push(p);\n\n    if (resolve) {\n      resolve();\n      resolve = null;\n    }\n  };\n\n  // accept callback or yield\n  async function connect(options?: RequestOptions) {\n    // invoke optional config request in the background, as we only need it after the ably authentication\n    if (!channels && !configPromise) {\n      configPromise = client\n        .request({ method: 'GET', path: '/config' }, options)\n        .then((x) => (channels = x.ws.channel));\n    }\n\n    const auth = await client.request<AuthResponse>({ method: 'POST', path: '/ws/auth' }, options);\n\n    // authenticate against ably\n    const { token } = await axios\n      .post<TokenResponse>(`https://rest.ably.io/keys/${auth.keyName}/requestToken`, auth)\n      .then((x) => x.data);\n\n    // make sure that the optional config request has finished\n    await configPromise;\n\n    // establish a connection with that token, the only reason we allow passing in the sseHost via args,\n    // is so that we have a way to reroute to localhost for testing.\n    const sseHost = args.sseHost || 'https://realtime.ably.io';\n    const url = new URL('sse', sseHost);\n\n    url.searchParams.append('v', '1.1');\n    url.searchParams.append('accessToken', token);\n    url.searchParams.append('channels', channels);\n    url.searchParams.append('heartbeats', 'true');\n\n    if (lastEvent) {\n      url.searchParams.append('lastEvent', lastEvent);\n    }\n\n    if (eventSource) {\n      eventSource.close();\n    }\n\n    eventSource = new EventSource(url.toString());\n\n    // handle incoming messages\n    eventSource.onmessage = (event) => {\n      if (event.origin !== sseHost) return;\n\n      lastEvent = event.lastEventId;\n      if (!('data' in event)) return;\n\n      const message = JSON.parse(event.data);\n      if (message.type === 'close') {\n        return pushMessage({ value: null, done: true });\n      }\n\n      message.data = message.encoding === 'json' ? JSON.parse(message.data) : message.data;\n      pushMessage({ value: message, done: false });\n    };\n\n    // handle connection errors\n    eventSource.onerror = (msg) => {\n      const err = 'data' in msg ? JSON.parse((msg as any).data) : {};\n      const isTokenErr = err.code >= 40140 && err.code < 40150;\n      if (isTokenErr) {\n        eventSource.close();\n        connect(options);\n      } else if (/invalid channel id/i.test(err.message)) {\n        eventSource.close();\n        pushMessage({ value: null, done: true });\n      } else {\n        // eslint-disable-next-line no-console\n        console.log('err', msg);\n      }\n    };\n  }\n\n  function listen(options?: RequestOptions): IterableEventSource<Event> {\n    void connect(options);\n\n    const asyncIteratorNext = async () => {\n      if (!messages.length) await new Promise((r) => (resolve = r));\n      const event = messages.pop();\n      if (event.done && eventSource) eventSource.close();\n      return event;\n    };\n\n    const dispose = () => {\n      eventSource.close();\n      return { done: true, value: undefined };\n    };\n\n    const forEach = makeForEach(asyncIteratorNext, dispose);\n    const autoPaginationMethods = {\n      forEach,\n\n      next: asyncIteratorNext,\n      return: dispose,\n      [ASYNC_ITERATOR_SYMBOL]: () => {\n        return autoPaginationMethods;\n      },\n    };\n\n    return autoPaginationMethods;\n  }\n\n  return listen;\n}\n","import { isBoolean, isNumber, isObject, isString } from './lib/utils';\nimport { ClientOptions } from './types';\n\nconst optionValidators: Record<keyof ClientOptions, (value: unknown) => boolean> = {\n  host: isString,\n  maxRetryDelay: isNumber,\n  timeout: isNumber,\n  apiKey: isString,\n  maxRetries: isNumber,\n  userEmail: isString,\n  userExternalId: isString,\n  userHmac: isString,\n  idempotencyKey: isString,\n  telemetry: isBoolean,\n  apiSecret: isString,\n  appInfo: isObject,\n  debug: isBoolean,\n  features: isObject,\n};\n\nexport function isOptionsHash(object) {\n  if (!isObject(object)) return false;\n\n  for (const key of Object.keys(object)) {\n    if (!optionValidators[key]?.(object[key])) return false;\n  }\n\n  return true;\n}\n","import { isArray, isBoolean, isObject, isString, isStringArray } from './lib/utils';\nimport { isOptionsHash } from './options';\nimport { ClientOptions, RequestMethod } from './types';\n\ntype KeyOfType<T, V> = keyof {\n  [P in keyof T as T[P] extends V ? P : never]: any;\n};\n\nexport type IterablePromise<\n  TData,\n  TKey extends KeyOfType<TData, Array<unknown>> = KeyOfType<TData, Array<unknown>>,\n  TNode = TData[TKey] extends Array<unknown> ? TData[TKey][number] : never,\n> = Promise<TData> & {\n  [Symbol.asyncIterator](): Iterator<TNode>;\n  forEach(cb: (node: TNode, index: number) => void | boolean | Promise<void | boolean>): Promise<void>;\n  toArray(options: { limit: number }): Promise<Array<TNode>>;\n};\n\nconst queryParamValidators = {\n  archived: isBoolean,\n  read: isBoolean,\n  seen: isBoolean,\n  categories: (value) => isString(value) || isStringArray(value),\n  topics: (value) => isString(value) || isStringArray(value),\n};\n\nfunction isForcedQueryParams(object) {\n  if (!isObject(object)) return false;\n\n  for (const key of Object.keys(object)) {\n    if (!queryParamValidators[key]?.(object[key])) return false;\n  }\n\n  return true;\n}\n\nfunction getUrl(path: string, params: Record<string, string>, options = { encode: true }) {\n  return path.replace(/{([\\s\\S]+?)}/g, ($0, $1) =>\n    options.encode ? encodeURIComponent(params[$1] || '') : params[$1] || '',\n  );\n}\n\nfunction extractUrlParams(path: string) {\n  const params = path.match(/{\\w+}/g) || [];\n  return (params || []).map((param) => param.replace(/[{}]/g, ''));\n}\n\n/**\n * Return the data argument from a list of arguments\n *\n * @param {object[]} args\n * @returns {object}\n */\nfunction getDataFromArgs(args): Record<string, unknown> {\n  if (!isArray(args) || !isObject(args[0])) return {};\n  if (isOptionsHash(args[0])) return {};\n  return args.shift();\n}\n\n/**\n * Return the options hash from a list of arguments\n */\nfunction getOptionsFromArgs(args): Partial<ClientOptions> {\n  if (!isArray(args) || args.length === 0) return {};\n\n  const arg = args[args.length - 1];\n  if (!isOptionsHash(arg)) return {};\n\n  return { ...args.pop() };\n}\n\nexport function normalizeArgs({\n  path,\n  method,\n  args,\n}: {\n  path: string;\n  method: RequestMethod;\n  args: (Record<string, unknown> | string)[];\n}) {\n  const argsCopy = [...args].filter((x) => x !== undefined);\n\n  const urlParams = extractUrlParams(path);\n  const urlData = urlParams.reduce((urlData, param) => {\n    const arg = argsCopy.shift();\n    if (typeof arg !== 'string') {\n      throw new Error(\n        `MagicBell: Argument \"${param}\" must be a string, but got ${typeof arg}: ${JSON.stringify(\n          arg,\n        )} (on API request to \\`${method} ${path}\\`)`,\n      );\n    }\n\n    urlData[param] = arg;\n    return urlData;\n  }, {});\n\n  // We don't encode atm because the backend doesn't support that in PUT /users/email:user@domain.com\n  const url = getUrl(path, urlData, { encode: false });\n  const dataFromArgs = getDataFromArgs(argsCopy);\n  const options = getOptionsFromArgs(argsCopy);\n\n  // Validate that there are no more args.\n  if (argsCopy.filter((x) => x != null).length) {\n    throw new Error(\n      `MagicBell: Unknown arguments (${JSON.stringify(argsCopy)}). (on API request to \\`${method} ${url}\\`)`,\n    );\n  }\n\n  // Note, DELETE requests should have data in the params, but our `subscriptions.delete`\n  //   endpoint reads it from the body. Other delete requests don't have data, so this seems\n  //   to be the best solution for now.\n  let dataInQuery = method === 'GET'; // || method === 'DELETE';\n\n  // We have a few POST methods using query data instead of body data.\n  if (method === 'POST' && isForcedQueryParams(dataFromArgs)) {\n    dataInQuery = true;\n  }\n\n  const data = dataInQuery ? {} : dataFromArgs;\n  const params = dataInQuery ? dataFromArgs : {};\n\n  return { path: url, data, params, options };\n}\n","import { Client } from './client';\nimport { joinUrlSegments } from './lib/utils';\nimport { IterablePromise, normalizeArgs } from './method';\nimport { autoPaginate } from './paginate';\n\ntype ResourceRequestOptions = {\n  method: 'GET' | 'PUT' | 'POST' | 'DELETE' | 'PATCH';\n  path?: string;\n  paged?: boolean;\n};\n\nfunction isEmptyPayload(data: unknown): boolean {\n  if (!data) return true;\n  if (Array.isArray(data)) return data.length === 0;\n  if (typeof data === 'object') return Object.keys(data).length === 0;\n  return false;\n}\n\nexport class Resource {\n  path: string;\n  entity: string;\n\n  protected client: InstanceType<typeof Client>;\n\n  constructor(client: InstanceType<typeof Client>) {\n    this.client = client;\n  }\n\n  protected request<TData = any>(\n    options: ResourceRequestOptions & { paged: true },\n    ...args: (string | Record<string, unknown>)[]\n  ): IterablePromise<TData>;\n\n  protected request<TData = any>(\n    options: ResourceRequestOptions & { paged?: false | never },\n    ...args: (string | Record<string, unknown>)[]\n  ): Promise<TData>;\n\n  protected request(\n    { method, paged, path: tplPath }: ResourceRequestOptions,\n    ...args: (string | Record<string, unknown>)[]\n  ) {\n    const { path, data, params, options } = normalizeArgs({\n      path: joinUrlSegments(this.path, tplPath),\n      method,\n      args,\n    });\n\n    const makeRequest = ({ data, params }) => {\n      const entity = this.entity || this.path;\n      data = isEmptyPayload(data) ? undefined : { [entity]: data };\n      params = isEmptyPayload(params) ? undefined : params;\n\n      return this.client\n        .request({ method, path, data, params }, options)\n        .then((response) => response[entity] || response);\n    };\n\n    if (paged) {\n      return autoPaginate(makeRequest, {\n        data,\n        params,\n      });\n    }\n\n    return makeRequest({ data, params });\n  }\n\n  protected assertFeatureFlag(flag: string) {\n    if (!this.client.hasFlag(flag)) {\n      throw new Error(`This is a beta feature, please enable it by providing the \"${flag}\" feature flag.`);\n    }\n  }\n}\n","// This file is generated. Do not update manually!\n\nimport { type FromSchema } from 'json-schema-to-ts';\n\nimport { Resource } from '../resource';\nimport * as schemas from '../schemas/imports';\nimport { type RequestOptions } from '../types';\n\ntype CreateImportsResponse = FromSchema<typeof schemas.CreateImportsResponseSchema>;\ntype CreateImportsPayload = FromSchema<typeof schemas.CreateImportsPayloadSchema>;\ntype GetImportsResponse = FromSchema<typeof schemas.GetImportsResponseSchema>;\n\nexport class Imports extends Resource {\n  path = 'imports';\n  entity = 'import';\n\n  /**\n   * Send a request to start the import of a list of users. The import allows the\n   * creation of slack connections as well.\n   *\n   * @param options - override client request options.\n   * @returns\n   **/\n  create(options?: RequestOptions): Promise<CreateImportsResponse>;\n\n  /**\n   * Send a request to start the import of a list of users. The import allows the\n   * creation of slack connections as well.\n   *\n   * @param data\n   * @param options - override client request options.\n   * @returns\n   **/\n  create(data: CreateImportsPayload, options?: RequestOptions): Promise<CreateImportsResponse>;\n\n  create(\n    dataOrOptions: CreateImportsPayload | RequestOptions,\n    options?: RequestOptions,\n  ): Promise<CreateImportsResponse> {\n    return this.request(\n      {\n        method: 'POST',\n      },\n      dataOrOptions,\n      options,\n    );\n  }\n\n  /**\n   * Send a request to query the status & errors of the import.\n   *\n   * @param importId - ID of the import.\n   *   The ID of the import is returned when the import is created.\n   * @param options - override client request options.\n   * @returns\n   **/\n  get(importId: string, options?: RequestOptions): Promise<GetImportsResponse> {\n    return this.request(\n      {\n        method: 'GET',\n        path: '{import_id}',\n      },\n      importId,\n      options,\n    );\n  }\n}\n","// This file is generated. Do not update manually!\n\nimport { type FromSchema } from 'json-schema-to-ts';\n\nimport { Resource } from '../resource';\nimport * as schemas from '../schemas/notification-preferences';\nimport { type RequestOptions } from '../types';\n\ntype GetNotificationPreferencesResponse = FromSchema<typeof schemas.GetNotificationPreferencesResponseSchema>;\ntype UpdateNotificationPreferencesResponse = FromSchema<typeof schemas.UpdateNotificationPreferencesResponseSchema>;\ntype UpdateNotificationPreferencesPayload = FromSchema<typeof schemas.UpdateNotificationPreferencesPayloadSchema>;\n\nexport class NotificationPreferences extends Resource {\n  path = 'notification_preferences';\n  entity = 'notification_preferences';\n\n  /**\n   * Fetch a user's notification preferences. If a user does not disable a channel\n   * explicitly, we would send notifications through that channel as long as your\n   * project is enabled.\n   *\n   * @param options - override client request options.\n   * @returns\n   **/\n  get(options?: RequestOptions): Promise<GetNotificationPreferencesResponse> {\n    return this.request(\n      {\n        method: 'GET',\n      },\n      options,\n    );\n  }\n\n  /**\n   * Update a user's notification preferences. These preferences will be applied only\n   * to channels you enabled for your project.\n   *\n   * @param options - override client request options.\n   * @returns\n   **/\n  update(options?: RequestOptions): Promise<UpdateNotificationPreferencesResponse>;\n\n  /**\n   * Update a user's notification preferences. These preferences will be applied only\n   * to channels you enabled for your project.\n   *\n   * @param data\n   * @param options - override client request options.\n   * @returns\n   **/\n  update(\n    data: UpdateNotificationPreferencesPayload,\n    options?: RequestOptions,\n  ): Promise<UpdateNotificationPreferencesResponse>;\n\n  update(\n    dataOrOptions: UpdateNotificationPreferencesPayload | RequestOptions,\n    options?: RequestOptions,\n  ): Promise<UpdateNotificationPreferencesResponse> {\n    return this.request(\n      {\n        method: 'PUT',\n      },\n      dataOrOptions,\n      options,\n    );\n  }\n}\n","// This file is generated. Do not update manually!\n\nimport { type FromSchema } from 'json-schema-to-ts';\n\nimport { type IterablePromise } from '../method';\nimport { Resource } from '../resource';\nimport * as schemas from '../schemas/notifications';\nimport { type RequestOptions } from '../types';\n\ntype CreateNotificationsResponse = FromSchema<typeof schemas.CreateNotificationsResponseSchema>;\ntype CreateNotificationsPayload = FromSchema<typeof schemas.CreateNotificationsPayloadSchema>;\ntype ListNotificationsResponse = FromSchema<typeof schemas.ListNotificationsResponseSchema>;\ntype ListNotificationsPayload = FromSchema<typeof schemas.ListNotificationsPayloadSchema>;\ntype GetNotificationsResponse = FromSchema<typeof schemas.GetNotificationsResponseSchema>;\ntype MarkAllReadNotificationsPayload = FromSchema<typeof schemas.MarkAllReadNotificationsPayloadSchema>;\ntype MarkAllSeenNotificationsPayload = FromSchema<typeof schemas.MarkAllSeenNotificationsPayloadSchema>;\n\nexport class Notifications extends Resource {\n  path = 'notifications';\n  entity = 'notification';\n\n  /**\n   * Send a notification to one or multiple users. You can identify users by their\n   * email address or by an external_id.\n   *\n   * You don't have to import your users into MagicBell. If a user does not exist\n   * we'll create it automatically.\n   *\n   * You can send user attributes like first_name, custom_attributes, and more when\n   * creating a notification.\n   *\n   * The new notification will be shown in the notification inbox of each recipient\n   * in real-time. It will also be delivered to each recipient through all channels\n   * you have enabled for your MagicBell project.\n   *\n   * @param data\n   * @param options - override client request options.\n   * @returns\n   **/\n  create(data: CreateNotificationsPayload, options?: RequestOptions): Promise<CreateNotificationsResponse> {\n    return this.request(\n      {\n        method: 'POST',\n      },\n      data,\n      options,\n    );\n  }\n\n  /**\n   * Fetch a user's notifications. Notifications are sorted in descendent order by\n   * the sent_at timestamp.\n   *\n   * @param options - override client request options.\n   * @returns\n   **/\n  list(options?: RequestOptions): IterablePromise<ListNotificationsResponse>;\n\n  /**\n   * Fetch a user's notifications. Notifications are sorted in descendent order by\n   * the sent_at timestamp.\n   *\n   * @param data\n   * @param options - override client request options.\n   * @returns\n   **/\n  list(data: ListNotificationsPayload, options?: RequestOptions): IterablePromise<ListNotificationsResponse>;\n\n  list(\n    dataOrOptions: ListNotificationsPayload | RequestOptions,\n    options?: RequestOptions,\n  ): IterablePromise<ListNotificationsResponse> {\n    return this.request(\n      {\n        method: 'GET',\n        paged: true,\n      },\n      dataOrOptions,\n      options,\n    );\n  }\n\n  /**\n   * Fetch a user's notification by its ID.\n   *\n   * @param notificationId - ID of the user notification.\n   *   The ID of a user notification can be obtained from the \"Fetch user\n   *   notifications\" API endpoint or from push events sent to the MagicBell React\n   *   library.\n   *\n   * @param options - override client request options.\n   * @returns\n   **/\n  get(notificationId: string, options?: RequestOptions): Promise<GetNotificationsResponse> {\n    return this.request(\n      {\n        method: 'GET',\n        path: '{notification_id}',\n      },\n      notificationId,\n      options,\n    );\n  }\n\n  /**\n   * Delete a user's notification by its ID. The notification is deleted immediately\n   * and removed from the user's notification inbox in real-time.\n   *\n   * @param notificationId - ID of the user notification.\n   *   The ID of a user notification can be obtained from the \"Fetch user\n   *   notifications\" API endpoint or from push events sent to the MagicBell React\n   *   library.\n   *\n   * @param options - override client request options.\n   **/\n  delete(notificationId: string, options?: RequestOptions): Promise<void> {\n    return this.request(\n      {\n        method: 'DELETE',\n        path: '{notification_id}',\n      },\n      notificationId,\n      options,\n    );\n  }\n\n  /**\n   * Mark a user notification as read. The notification will be automatically marked\n   * as seen, too.\n   *\n   * The new state will be reflected in the user's notification inbox in real-time.\n   *\n   * @param notificationId - ID of the user notification.\n   *   The ID of a user notification can be obtained from the \"Fetch user\n   *   notifications\" API endpoint or from push events sent to the MagicBell React\n   *   library.\n   *\n   * @param options - override client request options.\n   **/\n  markAsRead(notificationId: string, options?: RequestOptions): Promise<void> {\n    return this.request(\n      {\n        method: 'POST',\n        path: '{notification_id}/read',\n      },\n      notificationId,\n      options,\n    );\n  }\n\n  /**\n   * Mark a user notification as unread. The new state will be reflected in the\n   * user's notification inbox in real-time.\n   *\n   * @param notificationId - ID of the user notification.\n   *   The ID of a user notification can be obtained from the \"Fetch user\n   *   notifications\" API endpoint or from push events sent to the MagicBell React\n   *   library.\n   *\n   * @param options - override client request options.\n   **/\n  markAsUnread(notificationId: string, options?: RequestOptions): Promise<void> {\n    return this.request(\n      {\n        method: 'POST',\n        path: '{notification_id}/unread',\n      },\n      notificationId,\n      options,\n    );\n  }\n\n  /**\n   * Mark a user notification as archived.\n   *\n   * @param notificationId - ID of the user notification.\n   *   The ID of a user notification can be obtained from the \"Fetch user\n   *   notifications\" API endpoint or from push events sent to the MagicBell React\n   *   library.\n   *\n   * @param options - override client request options.\n   **/\n  archive(notificationId: string, options?: RequestOptions): Promise<void> {\n    return this.request(\n      {\n        method: 'POST',\n        path: '{notification_id}/archive',\n      },\n      notificationId,\n      options,\n    );\n  }\n\n  /**\n   * Mark a user notification as unarchived.\n   *\n   * @param notificationId - ID of the user notification.\n   *   The ID of a user notification can be obtained from the \"Fetch user\n   *   notifications\" API endpoint or from push events sent to the MagicBell React\n   *   library.\n   *\n   * @param options - override client request options.\n   **/\n  unarchive(notificationId: string, options?: RequestOptions): Promise<void> {\n    return this.request(\n      {\n        method: 'DELETE',\n        path: '{notification_id}/archive',\n      },\n      notificationId,\n      options,\n    );\n  }\n\n  /**\n   * Mark all notifications of a user as read. When you call this endpoint, the\n   * notification inboxes of this user will be updated in real-time.\n   *\n   * @param options - override client request options.\n   **/\n  markAllRead(options?: RequestOptions): Promise<void>;\n\n  /**\n   * Mark all notifications of a user as read. When you call this endpoint, the\n   * notification inboxes of this user will be updated in real-time.\n   *\n   * @param data\n   * @param options - override client request options.\n   **/\n  markAllRead(data: MarkAllReadNotificationsPayload, options?: RequestOptions): Promise<void>;\n\n  markAllRead(\n    dataOrOptions: MarkAllReadNotificationsPayload | RequestOptions,\n    options?: RequestOptions,\n  ): Promise<void> {\n    return this.request(\n      {\n        method: 'POST',\n        path: 'read',\n      },\n      dataOrOptions,\n      options,\n    );\n  }\n\n  /**\n   * Mark all notifications of a user as seen. When you call this endpoint, the\n   * notification inboxes of this user will be updated in real-time.\n   *\n   * @param options - override client request options.\n   **/\n  markAllSeen(options?: RequestOptions): Promise<void>;\n\n  /**\n   * Mark all notifications of a user as seen. When you call this endpoint, the\n   * notification inboxes of this user will be updated in real-time.\n   *\n   * @param data\n   * @param options - override client request options.\n   **/\n  markAllSeen(data: MarkAllSeenNotificationsPayload, options?: RequestOptions): Promise<void>;\n\n  markAllSeen(\n    dataOrOptions: MarkAllSeenNotificationsPayload | RequestOptions,\n    options?: RequestOptions,\n  ): Promise<void> {\n    return this.request(\n      {\n        method: 'POST',\n        path: 'seen',\n      },\n      dataOrOptions,\n      options,\n    );\n  }\n}\n","// This file is generated. Do not update manually!\n\nimport { type FromSchema } from 'json-schema-to-ts';\n\nimport { Resource } from '../resource';\nimport * as schemas from '../schemas/push-subscriptions';\nimport { type RequestOptions } from '../types';\n\ntype CreatePushSubscriptionsResponse = FromSchema<typeof schemas.CreatePushSubscriptionsResponseSchema>;\ntype CreatePushSubscriptionsPayload = FromSchema<typeof schemas.CreatePushSubscriptionsPayloadSchema>;\n\nexport class PushSubscriptions extends Resource {\n  path = 'push_subscriptions';\n  entity = 'push_subscription';\n\n  /**\n   * Register a device token for push notifications.\n   *\n   * Please keep in mind that mobile push notifications will be delivered to this\n   * device only if the channel is configured and enabled.\n   *\n   * @param data\n   * @param options - override client request options.\n   * @returns\n   *\n   * @beta\n   **/\n  create(data: CreatePushSubscriptionsPayload, options?: RequestOptions): Promise<CreatePushSubscriptionsResponse> {\n    this.assertFeatureFlag('push-subscriptions-create');\n\n    return this.request(\n      {\n        method: 'POST',\n      },\n      data,\n      options,\n    );\n  }\n\n  /**\n   * Remove the subscription of a device to mobile push notifications. The device\n   * will be discarded immediately.\n   *\n   * @param deviceToken - Token of the device you want to remove\n   * @param options - override client request options.\n   *\n   * @beta\n   **/\n  delete(deviceToken: string, options?: RequestOptions): Promise<void> {\n    this.assertFeatureFlag('push-subscriptions-delete');\n\n    return this.request(\n      {\n        method: 'DELETE',\n        path: '{device_token}',\n      },\n      deviceToken,\n      options,\n    );\n  }\n}\n","// This file is generated. Do not update manually!\n\nimport { type FromSchema } from 'json-schema-to-ts';\n\nimport { type IterablePromise } from '../method';\nimport { Resource } from '../resource';\nimport * as schemas from '../schemas/subscriptions';\nimport { type RequestOptions } from '../types';\n\ntype ListSubscriptionsResponse = FromSchema<typeof schemas.ListSubscriptionsResponseSchema>;\ntype CreateSubscriptionsResponse = FromSchema<typeof schemas.CreateSubscriptionsResponseSchema>;\ntype CreateSubscriptionsPayload = FromSchema<typeof schemas.CreateSubscriptionsPayloadSchema>;\ntype UnsubscribeSubscriptionsResponse = FromSchema<typeof schemas.UnsubscribeSubscriptionsResponseSchema>;\ntype UnsubscribeSubscriptionsPayload = FromSchema<typeof schemas.UnsubscribeSubscriptionsPayloadSchema>;\ntype GetSubscriptionsResponse = FromSchema<typeof schemas.GetSubscriptionsResponseSchema>;\ntype DeleteSubscriptionsPayload = FromSchema<typeof schemas.DeleteSubscriptionsPayloadSchema>;\n\nexport class Subscriptions extends Resource {\n  path = 'subscriptions';\n  entity = 'subscription';\n\n  /**\n   * List a user's subscriptions status for all topics and categories.\n   *\n   * @param options - override client request options.\n   * @returns\n   **/\n  list(options?: RequestOptions): IterablePromise<ListSubscriptionsResponse> {\n    return this.request(\n      {\n        method: 'GET',\n        paged: true,\n      },\n      options,\n    );\n  }\n\n  /**\n   * Set a user's subscription status to subscribed for a particular topic (and\n   * optional categories). If the user previously unsubscribed, the user will be\n   * resubscribed.\n   *\n   * @param data\n   * @param options - override client request options.\n   * @returns\n   **/\n  create(data: CreateSubscriptionsPayload, options?: RequestOptions): Promise<CreateSubscriptionsResponse> {\n    return this.request(\n      {\n        method: 'POST',\n      },\n      data,\n      options,\n    );\n  }\n\n  /**\n   * Unusbscribe a user from a particular topic (and optional categories).\n   *\n   * @param topic - The topic for which we'd like to filter topic subscriptions.\n   * @param data\n   * @param options - override client request options.\n   * @returns\n   **/\n  unsubscribe(\n    topic: string,\n    data: UnsubscribeSubscriptionsPayload,\n    options?: RequestOptions,\n  ): Promise<UnsubscribeSubscriptionsResponse> {\n    return this.request(\n      {\n        method: 'POST',\n        path: '{topic}/unsubscribe',\n      },\n      topic,\n      data,\n      options,\n    );\n  }\n\n  /**\n   * Show a user's subscription status for a particular topic and categories.\n   *\n   * @param topic - The topic for which we'd like to filter topic subscriptions.\n   * @param options - override client request options.\n   * @returns\n   **/\n  get(topic: string, options?: RequestOptions): Promise<GetSubscriptionsResponse> {\n    return this.request(\n      {\n        method: 'GET',\n        path: '{topic}',\n      },\n      topic,\n      options,\n    );\n  }\n\n  /**\n   * Delete topic subscription(s)\n   *\n   * @param topic - The topic for which we'd like to filter topic subscriptions.\n   * @param options - override client request options.\n   **/\n  delete(topic: string, options?: RequestOptions): Promise<void>;\n\n  /**\n   * Delete topic subscription(s)\n   *\n   * @param topic - The topic for which we'd like to filter topic subscriptions.\n   * @param data\n   * @param options - override client request options.\n   **/\n  delete(topic: string, data: DeleteSubscriptionsPayload, options?: RequestOptions): Promise<void>;\n\n  delete(\n    topic: string,\n    dataOrOptions: DeleteSubscriptionsPayload | RequestOptions,\n    options?: RequestOptions,\n  ): Promise<void> {\n    return this.request(\n      {\n        method: 'DELETE',\n        path: '{topic}',\n      },\n      topic,\n      dataOrOptions,\n      options,\n    );\n  }\n}\n","// This file is generated. Do not update manually!\n\nimport { type FromSchema } from 'json-schema-to-ts';\n\nimport { Resource } from '../resource';\nimport * as schemas from '../schemas/users';\nimport { type RequestOptions } from '../types';\n\ntype CreateUsersResponse = FromSchema<typeof schemas.CreateUsersResponseSchema>;\ntype CreateUsersPayload = FromSchema<typeof schemas.CreateUsersPayloadSchema>;\ntype UpdateUsersResponse = FromSchema<typeof schemas.UpdateUsersResponseSchema>;\ntype UpdateUsersPayload = FromSchema<typeof schemas.UpdateUsersPayloadSchema>;\ntype UpdateByEmailUsersResponse = FromSchema<typeof schemas.UpdateByEmailUsersResponseSchema>;\ntype UpdateByEmailUsersPayload = FromSchema<typeof schemas.UpdateByEmailUsersPayloadSchema>;\ntype UpdateByExternalIdUsersResponse = FromSchema<typeof schemas.UpdateByExternalIdUsersResponseSchema>;\ntype UpdateByExternalIdUsersPayload = FromSchema<typeof schemas.UpdateByExternalIdUsersPayloadSchema>;\n\nexport class Users extends Resource {\n  path = 'users';\n  entity = 'user';\n\n  /**\n   * Create a user. Please note that you must provide the user's email or the\n   * external id so MagicBell can uniquely identify the user.\n   *\n   * The external id, if provided, must be unique to the user.\n   *\n   * @param options - override client request options.\n   * @returns\n   **/\n  create(options?: RequestOptions): Promise<CreateUsersResponse>;\n\n  /**\n   * Create a user. Please note that you must provide the user's email or the\n   * external id so MagicBell can uniquely identify the user.\n   *\n   * The external id, if provided, must be unique to the user.\n   *\n   * @param data\n   * @param options - override client request options.\n   * @returns\n   **/\n  create(data: CreateUsersPayload, options?: RequestOptions): Promise<CreateUsersResponse>;\n\n  create(dataOrOptions: CreateUsersPayload | RequestOptions, options?: RequestOptions): Promise<CreateUsersResponse> {\n    return this.request(\n      {\n        method: 'POST',\n      },\n      dataOrOptions,\n      options,\n    );\n  }\n\n  /**\n   * Update a user's data. If you identify users by their email addresses, you need\n   * to update the MagicBell data, so this user can still access their notifications.\n   *\n   * @param userId - The user id is the MagicBell user id. Alternatively, provide an\n   *   id like `email:theusersemail@example.com` or `external_id:theusersexternalid` as\n   *   the user id.\n   * @param options - override client request options.\n   * @returns\n   **/\n  update(userId: string, options?: RequestOptions): Promise<UpdateUsersResponse>;\n\n  /**\n   * Update a user's data. If you identify users by their email addresses, you need\n   * to update the MagicBell data, so this user can still access their notifications.\n   *\n   * @param userId - The user id is the MagicBell user id. Alternatively, provide an\n   *   id like `email:theusersemail@example.com` or `external_id:theusersexternalid` as\n   *   the user id.\n   * @param data\n   * @param options - override client request options.\n   * @returns\n   **/\n  update(userId: string, data: UpdateUsersPayload, options?: RequestOptions): Promise<UpdateUsersResponse>;\n\n  update(\n    userId: string,\n    dataOrOptions: UpdateUsersPayload | RequestOptions,\n    options?: RequestOptions,\n  ): Promise<UpdateUsersResponse> {\n    return this.request(\n      {\n        method: 'PUT',\n        path: '{user_id}',\n      },\n      userId,\n      dataOrOptions,\n      options,\n    );\n  }\n\n  /**\n   * Immediately deletes a user.\n   *\n   * @param userId - The user id is the MagicBell user id. Alternatively, provide an\n   *   id like `email:theusersemail@example.com` or `external_id:theusersexternalid` as\n   *   the user id.\n   * @param options - override client request options.\n   **/\n  delete(userId: string, options?: RequestOptions): Promise<void> {\n    return this.request(\n      {\n        method: 'DELETE',\n        path: '{user_id}',\n      },\n      userId,\n      options,\n    );\n  }\n\n  /**\n   * Update a user's data. If you identify users by their email addresses, you need\n   * to update the MagicBell data, so this user can still access their notifications.\n   *\n   * @param userEmail\n   * @param options - override client request options.\n   * @returns\n   **/\n  updateByEmail(userEmail: string, options?: RequestOptions): Promise<UpdateByEmailUsersResponse>;\n\n  /**\n   * Update a user's data. If you identify users by their email addresses, you need\n   * to update the MagicBell data, so this user can still access their notifications.\n   *\n   * @param userEmail\n   * @param data\n   * @param options - override client request options.\n   * @returns\n   **/\n  updateByEmail(\n    userEmail: string,\n    data: UpdateByEmailUsersPayload,\n    options?: RequestOptions,\n  ): Promise<UpdateByEmailUsersResponse>;\n\n  updateByEmail(\n    userEmail: string,\n    dataOrOptions: UpdateByEmailUsersPayload | RequestOptions,\n    options?: RequestOptions,\n  ): Promise<UpdateByEmailUsersResponse> {\n    return this.request(\n      {\n        method: 'PUT',\n        path: 'email:{user_email}',\n      },\n      userEmail,\n      dataOrOptions,\n      options,\n    );\n  }\n\n  /**\n   * Immediately deletes a user.\n   *\n   * @param userEmail\n   * @param options - override client request options.\n   **/\n  deleteByEmail(userEmail: string, options?: RequestOptions): Promise<void> {\n    return this.request(\n      {\n        method: 'DELETE',\n        path: 'email:{user_email}',\n      },\n      userEmail,\n      options,\n    );\n  }\n\n  /**\n   * Update a user's data. If you identify users by their email addresses, you need\n   * to update the MagicBell data, so this user can still access their notifications.\n   *\n   * @param externalId\n   * @param options - override client request options.\n   * @returns\n   **/\n  updateByExternalId(externalId: string, options?: RequestOptions): Promise<UpdateByExternalIdUsersResponse>;\n\n  /**\n   * Update a user's data. If you identify users by their email addresses, you need\n   * to update the MagicBell data, so this user can still access their notifications.\n   *\n   * @param externalId\n   * @param data\n   * @param options - override client request options.\n   * @returns\n   **/\n  updateByExternalId(\n    externalId: string,\n    data: UpdateByExternalIdUsersPayload,\n    options?: RequestOptions,\n  ): Promise<UpdateByExternalIdUsersResponse>;\n\n  updateByExternalId(\n    externalId: string,\n    dataOrOptions: UpdateByExternalIdUsersPayload | RequestOptions,\n    options?: RequestOptions,\n  ): Promise<UpdateByExternalIdUsersResponse> {\n    return this.request(\n      {\n        method: 'PUT',\n        path: 'external_id:{external_id}',\n      },\n      externalId,\n      dataOrOptions,\n      options,\n    );\n  }\n\n  /**\n   * Immediately deletes a user.\n   *\n   * @param externalId\n   * @param options - override client request options.\n   **/\n  deleteByExternalId(externalId: string, options?: RequestOptions): Promise<void> {\n    return this.request(\n      {\n        method: 'DELETE',\n        path: 'external_id:{external_id}',\n      },\n      externalId,\n      options,\n    );\n  }\n}\n","import axios, { AxiosError, AxiosResponse } from 'axios';\n\nimport { createHmac } from './lib/crypto';\nimport { getClientUserAgent, getUserAgent } from './lib/env';\nimport { createError } from './lib/error';\nimport { normalizeHeaders } from './lib/headers';\nimport { Logger, toCurl } from './lib/log';\nimport { compact, hasOwn, joinAnd, sleep, uuid4 } from './lib/utils';\nimport { createListener } from './listen';\nimport { isOptionsHash } from './options';\nimport { Imports } from './resources/imports';\nimport { NotificationPreferences } from './resources/notification-preferences';\nimport { Notifications } from './resources/notifications';\nimport { PushSubscriptions } from './resources/push-subscriptions';\nimport { Subscriptions } from './resources/subscriptions';\nimport { Users } from './resources/users';\nimport { ClientOptions, RequestArgs, RequestMethod, RequestOptions } from './types';\n\n// some environments, like vscode extensions, don't have the XMLHttpRequest object defined.\nif (typeof XMLHttpRequest !== 'function') {\n  axios.defaults.adapter = require('axios/lib/adapters/http');\n}\n\nexport const DEFAULT_OPTIONS: Partial<ClientOptions> = {\n  host: 'https://api.magicbell.com',\n  timeout: 30_000,\n  maxRetries: 3,\n  maxRetryDelay: 60,\n  telemetry: true,\n};\n\ntype Telemetry = { id: string; runtime: number; duration: number; status: number };\n\nexport class Client {\n  #userAgent: string;\n  #clientUserAgent: string;\n  #options: ClientOptions;\n  #logger = new Logger();\n  #features: Record<string, boolean> = {};\n  #lastRequest: Telemetry[] = [];\n  listen = createListener(this);\n\n  imports = new Imports(this);\n  notificationPreferences = new NotificationPreferences(this);\n  notifications = new Notifications(this);\n  pushSubscriptions = new PushSubscriptions(this);\n  subscriptions = new Subscriptions(this);\n  users = new Users(this);\n\n  constructor(options: ClientOptions) {\n    const missingOptions = ['apiKey'].filter((x) => !hasOwn(options, x));\n    if (missingOptions.length) {\n      throw new Error(\n        `You haven't provided all required options, please provide ${joinAnd(...missingOptions)} to Client(options)`,\n      );\n    }\n\n    if (!isOptionsHash(options)) {\n      throw new Error(`You have provided invalid options. Please check your client options.`);\n    }\n\n    this.#options = Object.assign({}, DEFAULT_OPTIONS, options);\n    this.#logger.active = Boolean(this.#options.debug);\n    this.#clientUserAgent = getClientUserAgent(options.appInfo);\n    this.#userAgent = getUserAgent(options.appInfo);\n    this.#features = options.features || {};\n  }\n\n  hasFlag(flag: string) {\n    return this.#features[flag] || false;\n  }\n\n  async request<TResponse = any>({ method, path, data, params }: RequestArgs, options?: RequestOptions) {\n    const requestOptions = { ...this.#options, ...options };\n\n    // compute headers out of the retry-loop, only append the telemetry later\n    const headers = this.#getHeaders(requestOptions, method);\n\n    const maxRetries = Math.max(0, requestOptions.maxRetries);\n    for (let attempt = 1; attempt <= maxRetries; attempt++) {\n      let response: AxiosResponse<TResponse, any>;\n      let error: AxiosError | null;\n      const startTime = Date.now();\n\n      this.#logger.debug(`${method} ${path}`);\n      await axios({\n        method,\n        url: path,\n        baseURL: requestOptions.host,\n        headers: {\n          ...headers,\n          ...normalizeHeaders({\n            'X-MAGICBELL-CLIENT-TELEMETRY': this.#getTelemetryHeader(),\n          }),\n        },\n        data,\n        // TODO: verify arrays are serialized in a way we support\n        params,\n        timeout: requestOptions.timeout,\n      })\n        .then((res) => {\n          response = res;\n        })\n        .catch((e) => {\n          const curl = toCurl({ method, baseURL: requestOptions.host, url: path, data, params, headers });\n          this.#logger.error(`${e.message}: ${curl}`);\n\n          error = e;\n          response = e.response;\n        });\n\n      this.#logLastRequest(response, { startTime });\n\n      if (this.#shouldRetry(response, attempt, maxRetries)) {\n        const retryAfter = Number(response.headers['retry-after']);\n        await sleep(this.#getSleepTimeInMS(attempt, retryAfter, requestOptions.maxRetryDelay));\n        continue;\n      }\n\n      if (error) {\n        throw createError({\n          name: error.name,\n          message: error.message,\n          type: error['type'],\n          status: response.status,\n          statusText: response.statusText,\n          ...(response?.data as any)?.errors?.[0],\n        });\n      }\n\n      return response.data;\n    }\n  }\n\n  #getHeaders(options: ClientOptions, method: RequestMethod) {\n    let userHmac = options.userHmac;\n    if (!userHmac && options.apiSecret && (options.userExternalId || options.userEmail)) {\n      userHmac = createHmac(options.apiSecret, options.userExternalId || options.userEmail);\n    }\n\n    const isBrowser = typeof document !== 'undefined';\n\n    return compact(\n      normalizeHeaders({\n        // can't set user-agent in the browser, see https://developer.mozilla.org/en-US/docs/Glossary/Forbidden_header_name\n        'User-Agent': isBrowser ? null : this.#userAgent,\n        'Idempotency-Key': options.idempotencyKey || this.#getDefaultIdempotencyKey(method, options.maxRetries),\n        'Accept-Version': 'v2',\n        'X-MAGICBELL-API-KEY': options.apiKey,\n        'X-MAGICBELL-API-SECRET': options.apiSecret,\n        'X-MAGICBELL-CLIENT-USER-AGENT': this.#clientUserAgent,\n        'X-MAGICBELL-USER-EMAIL': options.userEmail,\n        'X-MAGICBELL-USER-EXTERNAL-ID': options.userExternalId,\n        'X-MAGICBELL-USER-HMAC': userHmac,\n      }),\n      true,\n    );\n  }\n\n  #logLastRequest(response: AxiosResponse | undefined, { startTime }) {\n    // don't collect telemetry if the user opted out.\n    if (!this.#options.telemetry || !response?.status) return;\n\n    const headers = normalizeHeaders(response.headers);\n    this.#lastRequest.push({\n      id: headers['X-Request-Id'],\n      runtime: Number(headers['X-Runtime']),\n      duration: Date.now() - startTime,\n      status: response.status,\n    });\n  }\n\n  #getTelemetryHeader() {\n    const telemetry = this.#lastRequest.pop();\n    if (!telemetry) return null;\n    return JSON.stringify(telemetry);\n  }\n\n  #shouldRetry(response: AxiosResponse | undefined, attempt: number, maxRetries: number) {\n    // Do not retry if we are out of retries.\n    if (attempt >= maxRetries) {\n      return false;\n    }\n\n    if (!response) {\n      return true;\n    }\n\n    // Use the server's recommendation if it provides one\n    if (response.headers['should-retry']) {\n      return response.headers['should-retry'] === 'true';\n    }\n\n    if (response.status === 409 || response.status === 503) {\n      // Retry on conflict, rate limit, and availability errors.\n      return true;\n    }\n\n    // Retry on 5xx's, except POST's, which our idempotency framework would just replay as 500's again anyway.\n    if (response.status >= 500 && response.request.method !== 'POST') {\n      return true;\n    }\n\n    return false;\n  }\n\n  #getSleepTimeInMS(numRetries: number, retryAfter = null, maxDelay: number) {\n    const firstDelay = 0.5;\n\n    // Apply exponential backoff between firstDelay and maxRetryDelay\n    let sleepSeconds = Math.min(firstDelay * Math.pow(numRetries, 2), maxDelay);\n\n    // Apply some jitter by randomizing the value in the range of 75% - 100% of sleepSeconds.\n    sleepSeconds *= 0.75 * (1 + Math.random());\n\n    // But never sleep less than the base sleep seconds.\n    sleepSeconds = Math.min(Math.max(firstDelay, sleepSeconds), maxDelay);\n\n    // And never sleep less than the time the API asks us to wait, assuming it's a reasonable ask.\n    if (Number.isInteger(retryAfter) && retryAfter <= 60) {\n      sleepSeconds = Math.max(sleepSeconds, retryAfter);\n    }\n\n    return sleepSeconds * 1000;\n  }\n\n  #getDefaultIdempotencyKey(method: RequestMethod, maxRetries: number) {\n    if (method !== 'POST' || maxRetries === 0) return;\n    return `magicbell-retry-${uuid4()}`;\n  }\n}\n"],"names":["createHmac","secret","data","crypto","getEnvInfo","common","__spreadProps","__spreadValues","_a","getAppInfoAsString","appInfo","getUserAgent","env","getClientUserAgent","createError","rawError","field","AuthenticationError","InvalidRequestError","APIError","RateLimitError","IdempotencyError","NotFoundError","UserInputError","UnknownError","BaseError","raw","__publicField","normalizeHeaders","headers","normalized","header","normalizeHeader","exceptions","text","colors","Logger","message","mask","str","secrets","isSecret","key","toCurl","method","baseURL","url","value","hasOwn","obj","prop","isString","isBoolean","isArray","isStringArray","x","isNumber","isObject","compact","dropEmptyString","result","uuid4","c","r","sleep","ms","resolve","joinAnd","parts","last","joinUrlSegments","segments","ASYNC_ITERATOR_SYMBOL","hasMore","pageResult","autoPaginate","makeRequest","params","promiseCache","reverseIteration","i","request","getNextPage","page","iterate","dataKey","idx","asyncIteratorNext","memoizedPromise","reject","forEach","makeForEach","toArray","makeToArray","autoPaginationMethods","cb","ret","onDoneCallback","onItem","handleIteration","iterResult","item","shouldContinue","options","limit","items","createListener","client","args","eventSource","channels","lastEvent","configPromise","messages","pushMessage","p","connect","auth","token","axios","sseHost","EventSource","event","msg","err","listen","dispose","optionValidators","isOptionsHash","object","queryParamValidators","isForcedQueryParams","getUrl","path","$0","$1","extractUrlParams","param","getDataFromArgs","getOptionsFromArgs","arg","normalizeArgs","argsCopy","urlData","dataFromArgs","dataInQuery","isEmptyPayload","Resource","paged","tplPath","entity","response","flag","Imports","dataOrOptions","importId","NotificationPreferences","Notifications","notificationId","PushSubscriptions","deviceToken","Subscriptions","topic","Users","userId","userEmail","externalId","DEFAULT_OPTIONS","Client","__privateAdd","_getHeaders","_logLastRequest","_getTelemetryHeader","_shouldRetry","_getSleepTimeInMS","_getDefaultIdempotencyKey","_userAgent","_clientUserAgent","_options","_logger","_features","_lastRequest","missingOptions","__privateSet","__privateGet","requestOptions","__privateMethod","getHeaders_fn","maxRetries","attempt","error","startTime","getTelemetryHeader_fn","res","e","curl","logLastRequest_fn","shouldRetry_fn","retryAfter","getSleepTimeInMS_fn","_b","userHmac","getDefaultIdempotencyKey_fn","telemetry","numRetries","maxDelay","sleepSeconds"],"mappings":"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"}