{"version":3,"file":"magicbell.esm.min.js","sources":["../src/lib/crypto.ts","../src/lib/env.ts","../src/lib/error.ts","../src/lib/headers.ts","../src/lib/log.ts","../src/lib/utils.ts","../src/paginate.ts","../src/listen.ts","../src/options.ts","../src/method.ts","../src/resource.ts","../src/resources/imports.ts","../src/resources/notification-preferences.ts","../src/resources/notifications.ts","../src/resources/push-subscriptions.ts","../src/resources/subscriptions.ts","../src/resources/users.ts","../src/client.ts"],"sourcesContent":["import crypto from 'crypto';\n\nexport function createHmac(secret: string, data: string) {\n  if (!secret || !data) return '';\n\n  if (!crypto || !crypto.createHmac) {\n    throw new Error('This method is not available in the browser. Please provide a userHmac.');\n  }\n\n  return crypto.createHmac('sha256', secret).update(data).digest('base64');\n}\n","import { ClientOptions } from '../types';\n\nexport function getEnvInfo() {\n  const common = {\n    binding: __PACKAGE_NAME__,\n    binding_version: __PACKAGE_VERSION__,\n    publisher: 'magicbell',\n  };\n\n  if (typeof process === 'undefined') {\n    return common;\n  }\n\n  return {\n    ...common,\n    runtime: process?.release?.name || 'node',\n    runtime_version: process.version,\n    platform: process.platform,\n    arch: process.arch,\n  };\n}\n\nfunction getAppInfoAsString(appInfo?: ClientOptions['appInfo']) {\n  if (!appInfo?.name) return '';\n\n  return [appInfo?.name, appInfo.version && `/${appInfo.version}`, appInfo.url && ` (${appInfo.url})`]\n    .filter(Boolean)\n    .join('');\n}\n\nexport function getUserAgent(appInfo?: ClientOptions['appInfo']) {\n  const env = getEnvInfo();\n\n  return [\n    `${env.binding}/${env.binding_version}`,\n    'runtime' in env && `${env.runtime}/${env.runtime_version}`,\n    getAppInfoAsString(appInfo),\n  ]\n    .filter(Boolean)\n    .join(' ');\n}\n\nexport function getClientUserAgent(appInfo?: ClientOptions['appInfo']) {\n  return JSON.stringify({ ...getEnvInfo(), application: appInfo });\n}\n","'use strict';\n\n// TODO: sync & cleanup\nexport function createError(rawError: ErrorConfig) {\n  for (const field of ['code', 'type', 'status']) {\n    switch (rawError[field]) {\n      case 'user_identifier_not_provided':\n        return new AuthenticationError(rawError);\n      case 'invalid_request_error':\n        return new InvalidRequestError(rawError);\n      case 'api_error':\n        return new APIError(rawError);\n      case 'authentication_error':\n        return new AuthenticationError(rawError);\n      case 'rate_limit_error':\n        return new RateLimitError(rawError);\n      case 'idempotency_error':\n        return new IdempotencyError(rawError);\n      case 404:\n        return new NotFoundError(rawError);\n      case 422:\n        return new UserInputError(rawError);\n    }\n  }\n\n  return new UnknownError(rawError);\n}\n\ntype ErrorConfig = {\n  name: string;\n  type?: string;\n  code?: string;\n  docs_url?: string;\n  help_link?: string;\n  status?: number;\n  statusText?: string;\n  message: string;\n  suggestion?: string;\n};\n\n/**\n * BaseError is the base error from which all other more specific errors derive.\n * Specifically for errors returned from REST API.\n */\nclass BaseError extends Error {\n  name: string;\n  message: string;\n  type?: string;\n  docs_url?: string;\n  code?: string;\n  status?: number;\n  statusText?: string;\n  suggestion?: string;\n\n  constructor(raw: ErrorConfig) {\n    super(raw.message);\n    this.type = this.constructor.name;\n    this.name = 'MagicBellError';\n    this.code = raw.code;\n    this.status = raw.status;\n    this.statusText = raw.statusText;\n    this.message = raw.message;\n    this.suggestion = raw.suggestion;\n    this.docs_url = raw.docs_url || raw.help_link;\n  }\n}\n\nexport class InvalidRequestError extends BaseError {}\nexport class UserInputError extends BaseError {}\nexport class APIError extends BaseError {}\nexport class AuthenticationError extends BaseError {}\nexport class PermissionError extends BaseError {}\nexport class RateLimitError extends BaseError {}\nexport class ConnectionError extends BaseError {}\nexport class IdempotencyError extends BaseError {}\nexport class UnknownError extends BaseError {}\nexport class NotFoundError extends BaseError {}\n","/**\n * Normalize standard HTTP Headers:\n * {'foo-bar': 'hi'}\n * becomes\n * {'Foo-Bar': 'hi'}\n */\nexport function normalizeHeaders(headers: Record<string, string>) {\n  if (!headers || typeof headers !== 'object') {\n    return headers;\n  }\n\n  const normalized = {};\n  for (const header of Object.keys(headers)) {\n    normalized[normalizeHeader(header)] = headers[header];\n  }\n\n  return normalized;\n}\n\n/**\n * Stolen from https://github.com/marten-de-vries/header-case-normalizer/blob/master/index.js#L36-L41\n * without the exceptions which are irrelevant to us.\n */\nfunction normalizeHeader(header) {\n  const exceptions = {\n    etag: 'ETag',\n    magicbell: 'MagicBell',\n  };\n\n  return header\n    .split('-')\n    .map((text) => exceptions[text.toLowerCase()] || text.charAt(0).toUpperCase() + text.slice(1).toLowerCase())\n    .join('-');\n}\n","import { AxiosRequestConfig } from 'axios';\n\nconst colors = {\n  reset: '\\x1b[0m',\n  magenta: '\\x1b[35m',\n  red: '\\x1b[31m',\n};\n\nexport function emitWarning(message) {\n  if (typeof process.emitWarning !== 'function') {\n    return console.warn(`magicbell: ${message}`);\n  }\n\n  return process.emitWarning(message, 'magicbell');\n}\n\nexport class Logger {\n  active = false;\n\n  debug(message) {\n    if (!this.active) return;\n\n    // eslint-disable-next-line no-console\n    console.log(`${colors.reset}${colors.magenta}magicbell:${colors.reset} ${message}`);\n  }\n\n  error(message) {\n    if (!this.active) return;\n\n    // eslint-disable-next-line no-console\n    console.error(`${colors.reset}${colors.red}magicbell:${colors.reset} ${message}`);\n  }\n}\n\nfunction mask(str: string) {\n  if (__DEV__) return str;\n  return `${str.slice(0, 4)}â€¦${str.slice(-4)}`;\n}\n\nconst secrets = /secret|token|key|password/i;\nfunction isSecret(key: string) {\n  return secrets.test(key);\n}\n\nexport function toCurl({ method, baseURL, url, data, headers }: AxiosRequestConfig) {\n  return [\n    `curl -X ${method.toUpperCase()}`,\n    `${baseURL}/${url.replace(/^\\//, '')}`,\n    Object.entries(headers)\n      .map(([key, value]) => `-H '${key}: ${isSecret(key) ? mask(String(value)) : value}'`)\n      .join(' '),\n    data && `-d '${JSON.stringify(data)}'`,\n  ].join(' ');\n}\n","export const hasOwn = (obj, prop) => Object.prototype.hasOwnProperty.call(obj, prop);\n\nexport const compose = <R>(fn1: (a: R) => R, ...fns: Array<(a: R) => R>) =>\n  fns.reduce((prevFn, nextFn) => (value) => prevFn(nextFn(value)), fn1);\n\nexport function isString(value) {\n  return typeof value === 'string';\n}\n\nexport function isBoolean(value) {\n  return typeof value === 'boolean';\n}\n\nexport function isArray(value) {\n  return Array.isArray(value);\n}\n\nexport function isStringArray(value) {\n  return Array.isArray(value) && value.every((x) => typeof x === 'string');\n}\n\nexport function isNumber(value) {\n  return typeof value === 'number';\n}\n\nexport function isObject(value) {\n  return value && typeof value === 'object';\n}\n\nexport function compact(obj: Record<string, unknown>, dropEmptyString = false) {\n  if (typeof obj !== 'object') {\n    throw new Error('Argument must be an object');\n  }\n\n  const result = {};\n  for (const key of Object.keys(obj)) {\n    if (obj[key] == null) continue;\n    if (dropEmptyString && obj[key] === '') continue;\n    result[key] = obj[key];\n  }\n\n  return result;\n}\n\nexport function uuid4() {\n  // TODO: should be upgradable to crypto.randomUUID(), introduced by node v14\n  return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, (c) => {\n    const r = (Math.random() * 16) | 0;\n    const v = c === 'x' ? r : (r & 0x3) | 0x8;\n    return v.toString(16);\n  });\n}\n\nexport async function sleep(ms: number) {\n  return new Promise((resolve) => setTimeout(resolve, ms));\n}\n\nexport function joinAnd(...parts) {\n  if (parts.length <= 2) return parts.join(' and ');\n\n  const last = parts.slice(-1)[0];\n  const others = parts.slice(0, -1);\n  return [others.join(', '), last].join(', and ');\n}\n\nexport function joinOr(...parts) {\n  if (parts.length <= 2) return parts.join(' or ');\n\n  const last = parts.slice(-1)[0];\n  const others = parts.slice(0, -1);\n  return [others.join(', '), last].join(', or ');\n}\n\nexport function joinUrlSegments(...segments) {\n  return ['/', ...segments].join('/').replace(/\\/+/g, '/').replace(/\\/$/, '');\n}\n","import { hasOwn } from './lib/utils';\n\nexport const ASYNC_ITERATOR_SYMBOL =\n  typeof Symbol !== 'undefined' && Symbol.asyncIterator ? Symbol.asyncIterator : '@@asyncIterator';\n\nfunction hasMore(pageResult) {\n  return (\n    hasOwn(pageResult, 'current_page') &&\n    hasOwn(pageResult, 'total_pages') &&\n    pageResult.current_page < pageResult.total_pages\n  );\n}\n\nexport function autoPaginate(makeRequest, { data, params }) {\n  const promiseCache = { currentPromise: null };\n  const reverseIteration = typeof params.after !== 'undefined';\n\n  let i = 0;\n  let request = makeRequest({ data, params });\n\n  const getNextPage = (pageResult) => {\n    const page = pageResult.current_page + 1;\n    return makeRequest({ data, params: { ...params, page } });\n  };\n\n  function iterate(pageResult) {\n    const dataKey = Object.keys(pageResult).find((key) => Array.isArray(pageResult[key]));\n    const data = pageResult[dataKey] || pageResult.data;\n\n    if (!data || typeof data.length !== 'number') {\n      throw Error('Unexpected: MagicBell API response does not have a well-formed response.');\n    }\n\n    if (i < data.length) {\n      const idx = reverseIteration ? data.length - 1 - i : i;\n      const value = data[idx];\n      i += 1;\n\n      return { value, done: false };\n    }\n\n    if (hasMore(pageResult)) {\n      // Reset counter, request next page, and recurse.\n      i = 0;\n      request = getNextPage(pageResult);\n      return request.then(iterate);\n    }\n\n    return { value: undefined, done: true };\n  }\n\n  function asyncIteratorNext() {\n    return memoizedPromise(promiseCache, (resolve, reject) => {\n      return request.then(iterate).then(resolve).catch(reject);\n    });\n  }\n\n  const forEach = makeForEach(asyncIteratorNext);\n  const toArray = makeToArray(forEach);\n\n  const autoPaginationMethods = {\n    forEach,\n    toArray,\n\n    next: asyncIteratorNext,\n    return: () => ({}),\n    [ASYNC_ITERATOR_SYMBOL]: () => {\n      return autoPaginationMethods;\n    },\n  };\n\n  return Object.assign(request, autoPaginationMethods);\n}\n\n/**\n * If a user calls `.next()` multiple times in parallel,\n * return the same result until something has resolved\n * to prevent page-turning race conditions.\n */\nfunction memoizedPromise(promiseCache, cb) {\n  if (promiseCache.currentPromise) {\n    return promiseCache.currentPromise;\n  }\n  promiseCache.currentPromise = new Promise(cb).then((ret) => {\n    promiseCache.currentPromise = undefined;\n    return ret;\n  });\n  return promiseCache.currentPromise;\n}\n\nexport function makeForEach(asyncIteratorNext, onDoneCallback?: () => void) {\n  return function forEach(onItem) {\n    return new Promise<void>((resolve, reject) => {\n      let idx = 0;\n      function handleIteration(iterResult) {\n        if (iterResult.done) {\n          resolve();\n          return;\n        }\n\n        const item = iterResult.value;\n        return new Promise((resolve) => {\n          resolve(onItem(item, idx));\n        }).then((shouldContinue) => {\n          if (shouldContinue === false) {\n            onDoneCallback?.();\n            return handleIteration({ done: true });\n          } else {\n            idx++;\n            return asyncIteratorNext().then(handleIteration);\n          }\n        });\n      }\n\n      asyncIteratorNext().then(handleIteration).catch(reject);\n    });\n  };\n}\n\nfunction makeToArray(forEach) {\n  return function toArray(options) {\n    const limit = options?.limit;\n    if (!limit) {\n      throw Error('You must pass a `limit` option to toArray, e.g., `toArray({ limit: 1000 });`.');\n    }\n\n    if (limit > 10_000) {\n      throw Error(\n        'You cannot specify a limit of more than 10,000 items to fetch in `toArray`; use `forEach` to iterate through longer lists.',\n      );\n    }\n\n    return new Promise((resolve, reject) => {\n      const items = [];\n      forEach((item) => {\n        items.push(item);\n        if (items.length >= limit) {\n          return false;\n        }\n      })\n        .then(() => {\n          resolve(items);\n        })\n        .catch(reject);\n    });\n  };\n}\n","import axios from 'axios';\nimport EventSource from 'eventsource';\n\nimport { Client } from './client';\nimport { ASYNC_ITERATOR_SYMBOL, makeForEach } from './paginate';\nimport { RequestOptions } from './types';\n\ntype AuthResponse = {\n  keyName: string;\n  timestamp: number;\n  nonce: string;\n  ttl: number;\n  mac: string;\n};\n\ntype TokenResponse = {\n  token: string;\n  keyName: string;\n  issued: number;\n  expires: number;\n  capability: string;\n  userClaims: string;\n};\n\ntype Event = {\n  id: string;\n  timestamp: number;\n  encoding: string;\n  channel: string;\n} & (\n  | { name: 'notifications/new'; data: { id: string } }\n  | { name: 'notifications/read'; data: { id: string; client_id: string } }\n  | { name: 'notifications/read/all'; data: { client_id: string } }\n  | { name: 'notifications/seen/all'; data: { client_id: string } }\n  | { name: 'notifications/unread'; data: { id: string; client_id: string } }\n  | { name: 'notifications/delete'; data: { id: string; client_id: string | null } }\n);\n\ntype IterableEventSource<TNode> = {\n  [Symbol.asyncIterator](): Iterator<TNode>;\n  forEach(cb: (node: TNode, index: number) => void | boolean | Promise<void | boolean>): Promise<void>;\n};\n\nexport type Listener = (options?: RequestOptions) => IterableEventSource<Event>;\n\nexport function createListener(client: InstanceType<typeof Client>, args: { sseHost?: string } = {}): Listener {\n  let eventSource: EventSource;\n  let channels: string;\n  let lastEvent: string;\n  let configPromise;\n\n  const messages: { value: Event; done: boolean }[] = [];\n  let resolve;\n\n  const pushMessage = (p) => {\n    messages.push(p);\n\n    if (resolve) {\n      resolve();\n      resolve = null;\n    }\n  };\n\n  // accept callback or yield\n  async function connect(options?: RequestOptions) {\n    // invoke optional config request in the background, as we only need it after the ably authentication\n    if (!channels && !configPromise) {\n      configPromise = client\n        .request({ method: 'GET', path: '/config' }, options)\n        .then((x) => (channels = x.ws.channel));\n    }\n\n    const auth = await client.request<AuthResponse>({ method: 'POST', path: '/ws/auth' }, options);\n\n    // authenticate against ably\n    const { token } = await axios\n      .post<TokenResponse>(`https://rest.ably.io/keys/${auth.keyName}/requestToken`, auth)\n      .then((x) => x.data);\n\n    // make sure that the optional config request has finished\n    await configPromise;\n\n    // establish a connection with that token, the only reason we allow passing in the sseHost via args,\n    // is so that we have a way to reroute to localhost for testing.\n    const sseHost = args.sseHost || 'https://realtime.ably.io';\n    const url = new URL('sse', sseHost);\n\n    url.searchParams.append('v', '1.1');\n    url.searchParams.append('accessToken', token);\n    url.searchParams.append('channels', channels);\n    url.searchParams.append('heartbeats', 'true');\n\n    if (lastEvent) {\n      url.searchParams.append('lastEvent', lastEvent);\n    }\n\n    if (eventSource) {\n      eventSource.close();\n    }\n\n    eventSource = new EventSource(url.toString());\n\n    // handle incoming messages\n    eventSource.onmessage = (event) => {\n      if (event.origin !== sseHost) return;\n\n      lastEvent = event.lastEventId;\n      if (!('data' in event)) return;\n\n      const message = JSON.parse(event.data);\n      if (message.type === 'close') {\n        return pushMessage({ value: null, done: true });\n      }\n\n      message.data = message.encoding === 'json' ? JSON.parse(message.data) : message.data;\n      pushMessage({ value: message, done: false });\n    };\n\n    // handle connection errors\n    eventSource.onerror = (msg) => {\n      const err = 'data' in msg ? JSON.parse((msg as any).data) : {};\n      const isTokenErr = err.code >= 40140 && err.code < 40150;\n      if (isTokenErr) {\n        eventSource.close();\n        connect(options);\n      } else if (/invalid channel id/i.test(err.message)) {\n        eventSource.close();\n        pushMessage({ value: null, done: true });\n      } else {\n        // eslint-disable-next-line no-console\n        console.log('err', msg);\n      }\n    };\n  }\n\n  function listen(options?: RequestOptions): IterableEventSource<Event> {\n    void connect(options);\n\n    const asyncIteratorNext = async () => {\n      if (!messages.length) await new Promise((r) => (resolve = r));\n      const event = messages.pop();\n      if (event.done && eventSource) eventSource.close();\n      return event;\n    };\n\n    const dispose = () => {\n      eventSource.close();\n      return { done: true, value: undefined };\n    };\n\n    const forEach = makeForEach(asyncIteratorNext, dispose);\n    const autoPaginationMethods = {\n      forEach,\n\n      next: asyncIteratorNext,\n      return: dispose,\n      [ASYNC_ITERATOR_SYMBOL]: () => {\n        return autoPaginationMethods;\n      },\n    };\n\n    return autoPaginationMethods;\n  }\n\n  return listen;\n}\n","import { isBoolean, isNumber, isObject, isString } from './lib/utils';\nimport { ClientOptions } from './types';\n\nconst optionValidators: Record<keyof ClientOptions, (value: unknown) => boolean> = {\n  host: isString,\n  maxRetryDelay: isNumber,\n  timeout: isNumber,\n  apiKey: isString,\n  maxRetries: isNumber,\n  userEmail: isString,\n  userExternalId: isString,\n  userHmac: isString,\n  idempotencyKey: isString,\n  telemetry: isBoolean,\n  apiSecret: isString,\n  appInfo: isObject,\n  debug: isBoolean,\n  features: isObject,\n};\n\nexport function isOptionsHash(object) {\n  if (!isObject(object)) return false;\n\n  for (const key of Object.keys(object)) {\n    if (!optionValidators[key]?.(object[key])) return false;\n  }\n\n  return true;\n}\n","import { isArray, isBoolean, isObject, isString, isStringArray } from './lib/utils';\nimport { isOptionsHash } from './options';\nimport { ClientOptions, RequestMethod } from './types';\n\ntype KeyOfType<T, V> = keyof {\n  [P in keyof T as T[P] extends V ? P : never]: any;\n};\n\nexport type IterablePromise<\n  TData,\n  TKey extends KeyOfType<TData, Array<unknown>> = KeyOfType<TData, Array<unknown>>,\n  TNode = TData[TKey] extends Array<unknown> ? TData[TKey][number] : never,\n> = Promise<TData> & {\n  [Symbol.asyncIterator](): Iterator<TNode>;\n  forEach(cb: (node: TNode, index: number) => void | boolean | Promise<void | boolean>): Promise<void>;\n  toArray(options: { limit: number }): Promise<Array<TNode>>;\n};\n\nconst queryParamValidators = {\n  archived: isBoolean,\n  read: isBoolean,\n  seen: isBoolean,\n  categories: (value) => isString(value) || isStringArray(value),\n  topics: (value) => isString(value) || isStringArray(value),\n};\n\nfunction isForcedQueryParams(object) {\n  if (!isObject(object)) return false;\n\n  for (const key of Object.keys(object)) {\n    if (!queryParamValidators[key]?.(object[key])) return false;\n  }\n\n  return true;\n}\n\nfunction getUrl(path: string, params: Record<string, string>, options = { encode: true }) {\n  return path.replace(/{([\\s\\S]+?)}/g, ($0, $1) =>\n    options.encode ? encodeURIComponent(params[$1] || '') : params[$1] || '',\n  );\n}\n\nfunction extractUrlParams(path: string) {\n  const params = path.match(/{\\w+}/g) || [];\n  return (params || []).map((param) => param.replace(/[{}]/g, ''));\n}\n\n/**\n * Return the data argument from a list of arguments\n *\n * @param {object[]} args\n * @returns {object}\n */\nfunction getDataFromArgs(args): Record<string, unknown> {\n  if (!isArray(args) || !isObject(args[0])) return {};\n  if (isOptionsHash(args[0])) return {};\n  return args.shift();\n}\n\n/**\n * Return the options hash from a list of arguments\n */\nfunction getOptionsFromArgs(args): Partial<ClientOptions> {\n  if (!isArray(args) || args.length === 0) return {};\n\n  const arg = args[args.length - 1];\n  if (!isOptionsHash(arg)) return {};\n\n  return { ...args.pop() };\n}\n\nexport function normalizeArgs({\n  path,\n  method,\n  args,\n}: {\n  path: string;\n  method: RequestMethod;\n  args: (Record<string, unknown> | string)[];\n}) {\n  const argsCopy = [...args].filter((x) => x !== undefined);\n\n  const urlParams = extractUrlParams(path);\n  const urlData = urlParams.reduce((urlData, param) => {\n    const arg = argsCopy.shift();\n    if (typeof arg !== 'string') {\n      throw new Error(\n        `MagicBell: Argument \"${param}\" must be a string, but got ${typeof arg}: ${JSON.stringify(\n          arg,\n        )} (on API request to \\`${method} ${path}\\`)`,\n      );\n    }\n\n    urlData[param] = arg;\n    return urlData;\n  }, {});\n\n  // We don't encode atm because the backend doesn't support that in PUT /users/email:user@domain.com\n  const url = getUrl(path, urlData, { encode: false });\n  const dataFromArgs = getDataFromArgs(argsCopy);\n  const options = getOptionsFromArgs(argsCopy);\n\n  // Validate that there are no more args.\n  if (argsCopy.filter((x) => x != null).length) {\n    throw new Error(\n      `MagicBell: Unknown arguments (${JSON.stringify(argsCopy)}). (on API request to \\`${method} ${url}\\`)`,\n    );\n  }\n\n  // Note, DELETE requests should have data in the params, but our `subscriptions.delete`\n  //   endpoint reads it from the body. Other delete requests don't have data, so this seems\n  //   to be the best solution for now.\n  let dataInQuery = method === 'GET'; // || method === 'DELETE';\n\n  // We have a few POST methods using query data instead of body data.\n  if (method === 'POST' && isForcedQueryParams(dataFromArgs)) {\n    dataInQuery = true;\n  }\n\n  const data = dataInQuery ? {} : dataFromArgs;\n  const params = dataInQuery ? dataFromArgs : {};\n\n  return { path: url, data, params, options };\n}\n","import { Client } from './client';\nimport { joinUrlSegments } from './lib/utils';\nimport { IterablePromise, normalizeArgs } from './method';\nimport { autoPaginate } from './paginate';\n\ntype ResourceRequestOptions = {\n  method: 'GET' | 'PUT' | 'POST' | 'DELETE' | 'PATCH';\n  path?: string;\n  paged?: boolean;\n};\n\nfunction isEmptyPayload(data: unknown): boolean {\n  if (!data) return true;\n  if (Array.isArray(data)) return data.length === 0;\n  if (typeof data === 'object') return Object.keys(data).length === 0;\n  return false;\n}\n\nexport class Resource {\n  path: string;\n  entity: string;\n\n  protected client: InstanceType<typeof Client>;\n\n  constructor(client: InstanceType<typeof Client>) {\n    this.client = client;\n  }\n\n  protected request<TData = any>(\n    options: ResourceRequestOptions & { paged: true },\n    ...args: (string | Record<string, unknown>)[]\n  ): IterablePromise<TData>;\n\n  protected request<TData = any>(\n    options: ResourceRequestOptions & { paged?: false | never },\n    ...args: (string | Record<string, unknown>)[]\n  ): Promise<TData>;\n\n  protected request(\n    { method, paged, path: tplPath }: ResourceRequestOptions,\n    ...args: (string | Record<string, unknown>)[]\n  ) {\n    const { path, data, params, options } = normalizeArgs({\n      path: joinUrlSegments(this.path, tplPath),\n      method,\n      args,\n    });\n\n    const makeRequest = ({ data, params }) => {\n      const entity = this.entity || this.path;\n      data = isEmptyPayload(data) ? undefined : { [entity]: data };\n      params = isEmptyPayload(params) ? undefined : params;\n\n      return this.client\n        .request({ method, path, data, params }, options)\n        .then((response) => response[entity] || response);\n    };\n\n    if (paged) {\n      return autoPaginate(makeRequest, {\n        data,\n        params,\n      });\n    }\n\n    return makeRequest({ data, params });\n  }\n\n  protected assertFeatureFlag(flag: string) {\n    if (!this.client.hasFlag(flag)) {\n      throw new Error(`This is a beta feature, please enable it by providing the \"${flag}\" feature flag.`);\n    }\n  }\n}\n","// This file is generated. Do not update manually!\n\nimport { type FromSchema } from 'json-schema-to-ts';\n\nimport { Resource } from '../resource';\nimport * as schemas from '../schemas/imports';\nimport { type RequestOptions } from '../types';\n\ntype CreateImportsResponse = FromSchema<typeof schemas.CreateImportsResponseSchema>;\ntype CreateImportsPayload = FromSchema<typeof schemas.CreateImportsPayloadSchema>;\ntype GetImportsResponse = FromSchema<typeof schemas.GetImportsResponseSchema>;\n\nexport class Imports extends Resource {\n  path = 'imports';\n  entity = 'import';\n\n  /**\n   * Send a request to start the import of a list of users. The import allows the\n   * creation of slack connections as well.\n   *\n   * @param options - override client request options.\n   * @returns\n   **/\n  create(options?: RequestOptions): Promise<CreateImportsResponse>;\n\n  /**\n   * Send a request to start the import of a list of users. The import allows the\n   * creation of slack connections as well.\n   *\n   * @param data\n   * @param options - override client request options.\n   * @returns\n   **/\n  create(data: CreateImportsPayload, options?: RequestOptions): Promise<CreateImportsResponse>;\n\n  create(\n    dataOrOptions: CreateImportsPayload | RequestOptions,\n    options?: RequestOptions,\n  ): Promise<CreateImportsResponse> {\n    return this.request(\n      {\n        method: 'POST',\n      },\n      dataOrOptions,\n      options,\n    );\n  }\n\n  /**\n   * Send a request to query the status & errors of the import.\n   *\n   * @param importId - ID of the import.\n   *   The ID of the import is returned when the import is created.\n   * @param options - override client request options.\n   * @returns\n   **/\n  get(importId: string, options?: RequestOptions): Promise<GetImportsResponse> {\n    return this.request(\n      {\n        method: 'GET',\n        path: '{import_id}',\n      },\n      importId,\n      options,\n    );\n  }\n}\n","// This file is generated. Do not update manually!\n\nimport { type FromSchema } from 'json-schema-to-ts';\n\nimport { Resource } from '../resource';\nimport * as schemas from '../schemas/notification-preferences';\nimport { type RequestOptions } from '../types';\n\ntype GetNotificationPreferencesResponse = FromSchema<typeof schemas.GetNotificationPreferencesResponseSchema>;\ntype UpdateNotificationPreferencesResponse = FromSchema<typeof schemas.UpdateNotificationPreferencesResponseSchema>;\ntype UpdateNotificationPreferencesPayload = FromSchema<typeof schemas.UpdateNotificationPreferencesPayloadSchema>;\n\nexport class NotificationPreferences extends Resource {\n  path = 'notification_preferences';\n  entity = 'notification_preferences';\n\n  /**\n   * Fetch a user's notification preferences. If a user does not disable a channel\n   * explicitly, we would send notifications through that channel as long as your\n   * project is enabled.\n   *\n   * @param options - override client request options.\n   * @returns\n   **/\n  get(options?: RequestOptions): Promise<GetNotificationPreferencesResponse> {\n    return this.request(\n      {\n        method: 'GET',\n      },\n      options,\n    );\n  }\n\n  /**\n   * Update a user's notification preferences. These preferences will be applied only\n   * to channels you enabled for your project.\n   *\n   * @param options - override client request options.\n   * @returns\n   **/\n  update(options?: RequestOptions): Promise<UpdateNotificationPreferencesResponse>;\n\n  /**\n   * Update a user's notification preferences. These preferences will be applied only\n   * to channels you enabled for your project.\n   *\n   * @param data\n   * @param options - override client request options.\n   * @returns\n   **/\n  update(\n    data: UpdateNotificationPreferencesPayload,\n    options?: RequestOptions,\n  ): Promise<UpdateNotificationPreferencesResponse>;\n\n  update(\n    dataOrOptions: UpdateNotificationPreferencesPayload | RequestOptions,\n    options?: RequestOptions,\n  ): Promise<UpdateNotificationPreferencesResponse> {\n    return this.request(\n      {\n        method: 'PUT',\n      },\n      dataOrOptions,\n      options,\n    );\n  }\n}\n","// This file is generated. Do not update manually!\n\nimport { type FromSchema } from 'json-schema-to-ts';\n\nimport { type IterablePromise } from '../method';\nimport { Resource } from '../resource';\nimport * as schemas from '../schemas/notifications';\nimport { type RequestOptions } from '../types';\n\ntype CreateNotificationsResponse = FromSchema<typeof schemas.CreateNotificationsResponseSchema>;\ntype CreateNotificationsPayload = FromSchema<typeof schemas.CreateNotificationsPayloadSchema>;\ntype ListNotificationsResponse = FromSchema<typeof schemas.ListNotificationsResponseSchema>;\ntype ListNotificationsPayload = FromSchema<typeof schemas.ListNotificationsPayloadSchema>;\ntype GetNotificationsResponse = FromSchema<typeof schemas.GetNotificationsResponseSchema>;\ntype MarkAllReadNotificationsPayload = FromSchema<typeof schemas.MarkAllReadNotificationsPayloadSchema>;\ntype MarkAllSeenNotificationsPayload = FromSchema<typeof schemas.MarkAllSeenNotificationsPayloadSchema>;\n\nexport class Notifications extends Resource {\n  path = 'notifications';\n  entity = 'notification';\n\n  /**\n   * Send a notification to one or multiple users. You can identify users by their\n   * email address or by an external_id.\n   *\n   * You don't have to import your users into MagicBell. If a user does not exist\n   * we'll create it automatically.\n   *\n   * You can send user attributes like first_name, custom_attributes, and more when\n   * creating a notification.\n   *\n   * The new notification will be shown in the notification inbox of each recipient\n   * in real-time. It will also be delivered to each recipient through all channels\n   * you have enabled for your MagicBell project.\n   *\n   * @param data\n   * @param options - override client request options.\n   * @returns\n   **/\n  create(data: CreateNotificationsPayload, options?: RequestOptions): Promise<CreateNotificationsResponse> {\n    return this.request(\n      {\n        method: 'POST',\n      },\n      data,\n      options,\n    );\n  }\n\n  /**\n   * Fetch a user's notifications. Notifications are sorted in descendent order by\n   * the sent_at timestamp.\n   *\n   * @param options - override client request options.\n   * @returns\n   **/\n  list(options?: RequestOptions): IterablePromise<ListNotificationsResponse>;\n\n  /**\n   * Fetch a user's notifications. Notifications are sorted in descendent order by\n   * the sent_at timestamp.\n   *\n   * @param data\n   * @param options - override client request options.\n   * @returns\n   **/\n  list(data: ListNotificationsPayload, options?: RequestOptions): IterablePromise<ListNotificationsResponse>;\n\n  list(\n    dataOrOptions: ListNotificationsPayload | RequestOptions,\n    options?: RequestOptions,\n  ): IterablePromise<ListNotificationsResponse> {\n    return this.request(\n      {\n        method: 'GET',\n        paged: true,\n      },\n      dataOrOptions,\n      options,\n    );\n  }\n\n  /**\n   * Fetch a user's notification by its ID.\n   *\n   * @param notificationId - ID of the user notification.\n   *   The ID of a user notification can be obtained from the \"Fetch user\n   *   notifications\" API endpoint or from push events sent to the MagicBell React\n   *   library.\n   *\n   * @param options - override client request options.\n   * @returns\n   **/\n  get(notificationId: string, options?: RequestOptions): Promise<GetNotificationsResponse> {\n    return this.request(\n      {\n        method: 'GET',\n        path: '{notification_id}',\n      },\n      notificationId,\n      options,\n    );\n  }\n\n  /**\n   * Delete a user's notification by its ID. The notification is deleted immediately\n   * and removed from the user's notification inbox in real-time.\n   *\n   * @param notificationId - ID of the user notification.\n   *   The ID of a user notification can be obtained from the \"Fetch user\n   *   notifications\" API endpoint or from push events sent to the MagicBell React\n   *   library.\n   *\n   * @param options - override client request options.\n   **/\n  delete(notificationId: string, options?: RequestOptions): Promise<void> {\n    return this.request(\n      {\n        method: 'DELETE',\n        path: '{notification_id}',\n      },\n      notificationId,\n      options,\n    );\n  }\n\n  /**\n   * Mark a user notification as read. The notification will be automatically marked\n   * as seen, too.\n   *\n   * The new state will be reflected in the user's notification inbox in real-time.\n   *\n   * @param notificationId - ID of the user notification.\n   *   The ID of a user notification can be obtained from the \"Fetch user\n   *   notifications\" API endpoint or from push events sent to the MagicBell React\n   *   library.\n   *\n   * @param options - override client request options.\n   **/\n  markAsRead(notificationId: string, options?: RequestOptions): Promise<void> {\n    return this.request(\n      {\n        method: 'POST',\n        path: '{notification_id}/read',\n      },\n      notificationId,\n      options,\n    );\n  }\n\n  /**\n   * Mark a user notification as unread. The new state will be reflected in the\n   * user's notification inbox in real-time.\n   *\n   * @param notificationId - ID of the user notification.\n   *   The ID of a user notification can be obtained from the \"Fetch user\n   *   notifications\" API endpoint or from push events sent to the MagicBell React\n   *   library.\n   *\n   * @param options - override client request options.\n   **/\n  markAsUnread(notificationId: string, options?: RequestOptions): Promise<void> {\n    return this.request(\n      {\n        method: 'POST',\n        path: '{notification_id}/unread',\n      },\n      notificationId,\n      options,\n    );\n  }\n\n  /**\n   * Mark a user notification as archived.\n   *\n   * @param notificationId - ID of the user notification.\n   *   The ID of a user notification can be obtained from the \"Fetch user\n   *   notifications\" API endpoint or from push events sent to the MagicBell React\n   *   library.\n   *\n   * @param options - override client request options.\n   **/\n  archive(notificationId: string, options?: RequestOptions): Promise<void> {\n    return this.request(\n      {\n        method: 'POST',\n        path: '{notification_id}/archive',\n      },\n      notificationId,\n      options,\n    );\n  }\n\n  /**\n   * Mark a user notification as unarchived.\n   *\n   * @param notificationId - ID of the user notification.\n   *   The ID of a user notification can be obtained from the \"Fetch user\n   *   notifications\" API endpoint or from push events sent to the MagicBell React\n   *   library.\n   *\n   * @param options - override client request options.\n   **/\n  unarchive(notificationId: string, options?: RequestOptions): Promise<void> {\n    return this.request(\n      {\n        method: 'DELETE',\n        path: '{notification_id}/archive',\n      },\n      notificationId,\n      options,\n    );\n  }\n\n  /**\n   * Mark all notifications of a user as read. When you call this endpoint, the\n   * notification inboxes of this user will be updated in real-time.\n   *\n   * @param options - override client request options.\n   **/\n  markAllRead(options?: RequestOptions): Promise<void>;\n\n  /**\n   * Mark all notifications of a user as read. When you call this endpoint, the\n   * notification inboxes of this user will be updated in real-time.\n   *\n   * @param data\n   * @param options - override client request options.\n   **/\n  markAllRead(data: MarkAllReadNotificationsPayload, options?: RequestOptions): Promise<void>;\n\n  markAllRead(\n    dataOrOptions: MarkAllReadNotificationsPayload | RequestOptions,\n    options?: RequestOptions,\n  ): Promise<void> {\n    return this.request(\n      {\n        method: 'POST',\n        path: 'read',\n      },\n      dataOrOptions,\n      options,\n    );\n  }\n\n  /**\n   * Mark all notifications of a user as seen. When you call this endpoint, the\n   * notification inboxes of this user will be updated in real-time.\n   *\n   * @param options - override client request options.\n   **/\n  markAllSeen(options?: RequestOptions): Promise<void>;\n\n  /**\n   * Mark all notifications of a user as seen. When you call this endpoint, the\n   * notification inboxes of this user will be updated in real-time.\n   *\n   * @param data\n   * @param options - override client request options.\n   **/\n  markAllSeen(data: MarkAllSeenNotificationsPayload, options?: RequestOptions): Promise<void>;\n\n  markAllSeen(\n    dataOrOptions: MarkAllSeenNotificationsPayload | RequestOptions,\n    options?: RequestOptions,\n  ): Promise<void> {\n    return this.request(\n      {\n        method: 'POST',\n        path: 'seen',\n      },\n      dataOrOptions,\n      options,\n    );\n  }\n}\n","// This file is generated. Do not update manually!\n\nimport { type FromSchema } from 'json-schema-to-ts';\n\nimport { Resource } from '../resource';\nimport * as schemas from '../schemas/push-subscriptions';\nimport { type RequestOptions } from '../types';\n\ntype CreatePushSubscriptionsResponse = FromSchema<typeof schemas.CreatePushSubscriptionsResponseSchema>;\ntype CreatePushSubscriptionsPayload = FromSchema<typeof schemas.CreatePushSubscriptionsPayloadSchema>;\n\nexport class PushSubscriptions extends Resource {\n  path = 'push_subscriptions';\n  entity = 'push_subscription';\n\n  /**\n   * Register a device token for push notifications.\n   *\n   * Please keep in mind that mobile push notifications will be delivered to this\n   * device only if the channel is configured and enabled.\n   *\n   * @param data\n   * @param options - override client request options.\n   * @returns\n   *\n   * @beta\n   **/\n  create(data: CreatePushSubscriptionsPayload, options?: RequestOptions): Promise<CreatePushSubscriptionsResponse> {\n    this.assertFeatureFlag('push-subscriptions-create');\n\n    return this.request(\n      {\n        method: 'POST',\n      },\n      data,\n      options,\n    );\n  }\n\n  /**\n   * Remove the subscription of a device to mobile push notifications. The device\n   * will be discarded immediately.\n   *\n   * @param deviceToken - Token of the device you want to remove\n   * @param options - override client request options.\n   *\n   * @beta\n   **/\n  delete(deviceToken: string, options?: RequestOptions): Promise<void> {\n    this.assertFeatureFlag('push-subscriptions-delete');\n\n    return this.request(\n      {\n        method: 'DELETE',\n        path: '{device_token}',\n      },\n      deviceToken,\n      options,\n    );\n  }\n}\n","// This file is generated. Do not update manually!\n\nimport { type FromSchema } from 'json-schema-to-ts';\n\nimport { type IterablePromise } from '../method';\nimport { Resource } from '../resource';\nimport * as schemas from '../schemas/subscriptions';\nimport { type RequestOptions } from '../types';\n\ntype ListSubscriptionsResponse = FromSchema<typeof schemas.ListSubscriptionsResponseSchema>;\ntype CreateSubscriptionsResponse = FromSchema<typeof schemas.CreateSubscriptionsResponseSchema>;\ntype CreateSubscriptionsPayload = FromSchema<typeof schemas.CreateSubscriptionsPayloadSchema>;\ntype UnsubscribeSubscriptionsResponse = FromSchema<typeof schemas.UnsubscribeSubscriptionsResponseSchema>;\ntype UnsubscribeSubscriptionsPayload = FromSchema<typeof schemas.UnsubscribeSubscriptionsPayloadSchema>;\ntype GetSubscriptionsResponse = FromSchema<typeof schemas.GetSubscriptionsResponseSchema>;\ntype DeleteSubscriptionsPayload = FromSchema<typeof schemas.DeleteSubscriptionsPayloadSchema>;\n\nexport class Subscriptions extends Resource {\n  path = 'subscriptions';\n  entity = 'subscription';\n\n  /**\n   * List a user's subscriptions status for all topics and categories.\n   *\n   * @param options - override client request options.\n   * @returns\n   **/\n  list(options?: RequestOptions): IterablePromise<ListSubscriptionsResponse> {\n    return this.request(\n      {\n        method: 'GET',\n        paged: true,\n      },\n      options,\n    );\n  }\n\n  /**\n   * Set a user's subscription status to subscribed for a particular topic (and\n   * optional categories). If the user previously unsubscribed, the user will be\n   * resubscribed.\n   *\n   * @param data\n   * @param options - override client request options.\n   * @returns\n   **/\n  create(data: CreateSubscriptionsPayload, options?: RequestOptions): Promise<CreateSubscriptionsResponse> {\n    return this.request(\n      {\n        method: 'POST',\n      },\n      data,\n      options,\n    );\n  }\n\n  /**\n   * Unusbscribe a user from a particular topic (and optional categories).\n   *\n   * @param topic - The topic for which we'd like to filter topic subscriptions.\n   * @param data\n   * @param options - override client request options.\n   * @returns\n   **/\n  unsubscribe(\n    topic: string,\n    data: UnsubscribeSubscriptionsPayload,\n    options?: RequestOptions,\n  ): Promise<UnsubscribeSubscriptionsResponse> {\n    return this.request(\n      {\n        method: 'POST',\n        path: '{topic}/unsubscribe',\n      },\n      topic,\n      data,\n      options,\n    );\n  }\n\n  /**\n   * Show a user's subscription status for a particular topic and categories.\n   *\n   * @param topic - The topic for which we'd like to filter topic subscriptions.\n   * @param options - override client request options.\n   * @returns\n   **/\n  get(topic: string, options?: RequestOptions): Promise<GetSubscriptionsResponse> {\n    return this.request(\n      {\n        method: 'GET',\n        path: '{topic}',\n      },\n      topic,\n      options,\n    );\n  }\n\n  /**\n   * Delete topic subscription(s)\n   *\n   * @param topic - The topic for which we'd like to filter topic subscriptions.\n   * @param options - override client request options.\n   **/\n  delete(topic: string, options?: RequestOptions): Promise<void>;\n\n  /**\n   * Delete topic subscription(s)\n   *\n   * @param topic - The topic for which we'd like to filter topic subscriptions.\n   * @param data\n   * @param options - override client request options.\n   **/\n  delete(topic: string, data: DeleteSubscriptionsPayload, options?: RequestOptions): Promise<void>;\n\n  delete(\n    topic: string,\n    dataOrOptions: DeleteSubscriptionsPayload | RequestOptions,\n    options?: RequestOptions,\n  ): Promise<void> {\n    return this.request(\n      {\n        method: 'DELETE',\n        path: '{topic}',\n      },\n      topic,\n      dataOrOptions,\n      options,\n    );\n  }\n}\n","// This file is generated. Do not update manually!\n\nimport { type FromSchema } from 'json-schema-to-ts';\n\nimport { Resource } from '../resource';\nimport * as schemas from '../schemas/users';\nimport { type RequestOptions } from '../types';\n\ntype CreateUsersResponse = FromSchema<typeof schemas.CreateUsersResponseSchema>;\ntype CreateUsersPayload = FromSchema<typeof schemas.CreateUsersPayloadSchema>;\ntype UpdateUsersResponse = FromSchema<typeof schemas.UpdateUsersResponseSchema>;\ntype UpdateUsersPayload = FromSchema<typeof schemas.UpdateUsersPayloadSchema>;\ntype UpdateByEmailUsersResponse = FromSchema<typeof schemas.UpdateByEmailUsersResponseSchema>;\ntype UpdateByEmailUsersPayload = FromSchema<typeof schemas.UpdateByEmailUsersPayloadSchema>;\ntype UpdateByExternalIdUsersResponse = FromSchema<typeof schemas.UpdateByExternalIdUsersResponseSchema>;\ntype UpdateByExternalIdUsersPayload = FromSchema<typeof schemas.UpdateByExternalIdUsersPayloadSchema>;\n\nexport class Users extends Resource {\n  path = 'users';\n  entity = 'user';\n\n  /**\n   * Create a user. Please note that you must provide the user's email or the\n   * external id so MagicBell can uniquely identify the user.\n   *\n   * The external id, if provided, must be unique to the user.\n   *\n   * @param options - override client request options.\n   * @returns\n   **/\n  create(options?: RequestOptions): Promise<CreateUsersResponse>;\n\n  /**\n   * Create a user. Please note that you must provide the user's email or the\n   * external id so MagicBell can uniquely identify the user.\n   *\n   * The external id, if provided, must be unique to the user.\n   *\n   * @param data\n   * @param options - override client request options.\n   * @returns\n   **/\n  create(data: CreateUsersPayload, options?: RequestOptions): Promise<CreateUsersResponse>;\n\n  create(dataOrOptions: CreateUsersPayload | RequestOptions, options?: RequestOptions): Promise<CreateUsersResponse> {\n    return this.request(\n      {\n        method: 'POST',\n      },\n      dataOrOptions,\n      options,\n    );\n  }\n\n  /**\n   * Update a user's data. If you identify users by their email addresses, you need\n   * to update the MagicBell data, so this user can still access their notifications.\n   *\n   * @param userId - The user id is the MagicBell user id. Alternatively, provide an\n   *   id like `email:theusersemail@example.com` or `external_id:theusersexternalid` as\n   *   the user id.\n   * @param options - override client request options.\n   * @returns\n   **/\n  update(userId: string, options?: RequestOptions): Promise<UpdateUsersResponse>;\n\n  /**\n   * Update a user's data. If you identify users by their email addresses, you need\n   * to update the MagicBell data, so this user can still access their notifications.\n   *\n   * @param userId - The user id is the MagicBell user id. Alternatively, provide an\n   *   id like `email:theusersemail@example.com` or `external_id:theusersexternalid` as\n   *   the user id.\n   * @param data\n   * @param options - override client request options.\n   * @returns\n   **/\n  update(userId: string, data: UpdateUsersPayload, options?: RequestOptions): Promise<UpdateUsersResponse>;\n\n  update(\n    userId: string,\n    dataOrOptions: UpdateUsersPayload | RequestOptions,\n    options?: RequestOptions,\n  ): Promise<UpdateUsersResponse> {\n    return this.request(\n      {\n        method: 'PUT',\n        path: '{user_id}',\n      },\n      userId,\n      dataOrOptions,\n      options,\n    );\n  }\n\n  /**\n   * Immediately deletes a user.\n   *\n   * @param userId - The user id is the MagicBell user id. Alternatively, provide an\n   *   id like `email:theusersemail@example.com` or `external_id:theusersexternalid` as\n   *   the user id.\n   * @param options - override client request options.\n   **/\n  delete(userId: string, options?: RequestOptions): Promise<void> {\n    return this.request(\n      {\n        method: 'DELETE',\n        path: '{user_id}',\n      },\n      userId,\n      options,\n    );\n  }\n\n  /**\n   * Update a user's data. If you identify users by their email addresses, you need\n   * to update the MagicBell data, so this user can still access their notifications.\n   *\n   * @param userEmail\n   * @param options - override client request options.\n   * @returns\n   **/\n  updateByEmail(userEmail: string, options?: RequestOptions): Promise<UpdateByEmailUsersResponse>;\n\n  /**\n   * Update a user's data. If you identify users by their email addresses, you need\n   * to update the MagicBell data, so this user can still access their notifications.\n   *\n   * @param userEmail\n   * @param data\n   * @param options - override client request options.\n   * @returns\n   **/\n  updateByEmail(\n    userEmail: string,\n    data: UpdateByEmailUsersPayload,\n    options?: RequestOptions,\n  ): Promise<UpdateByEmailUsersResponse>;\n\n  updateByEmail(\n    userEmail: string,\n    dataOrOptions: UpdateByEmailUsersPayload | RequestOptions,\n    options?: RequestOptions,\n  ): Promise<UpdateByEmailUsersResponse> {\n    return this.request(\n      {\n        method: 'PUT',\n        path: 'email:{user_email}',\n      },\n      userEmail,\n      dataOrOptions,\n      options,\n    );\n  }\n\n  /**\n   * Immediately deletes a user.\n   *\n   * @param userEmail\n   * @param options - override client request options.\n   **/\n  deleteByEmail(userEmail: string, options?: RequestOptions): Promise<void> {\n    return this.request(\n      {\n        method: 'DELETE',\n        path: 'email:{user_email}',\n      },\n      userEmail,\n      options,\n    );\n  }\n\n  /**\n   * Update a user's data. If you identify users by their email addresses, you need\n   * to update the MagicBell data, so this user can still access their notifications.\n   *\n   * @param externalId\n   * @param options - override client request options.\n   * @returns\n   **/\n  updateByExternalId(externalId: string, options?: RequestOptions): Promise<UpdateByExternalIdUsersResponse>;\n\n  /**\n   * Update a user's data. If you identify users by their email addresses, you need\n   * to update the MagicBell data, so this user can still access their notifications.\n   *\n   * @param externalId\n   * @param data\n   * @param options - override client request options.\n   * @returns\n   **/\n  updateByExternalId(\n    externalId: string,\n    data: UpdateByExternalIdUsersPayload,\n    options?: RequestOptions,\n  ): Promise<UpdateByExternalIdUsersResponse>;\n\n  updateByExternalId(\n    externalId: string,\n    dataOrOptions: UpdateByExternalIdUsersPayload | RequestOptions,\n    options?: RequestOptions,\n  ): Promise<UpdateByExternalIdUsersResponse> {\n    return this.request(\n      {\n        method: 'PUT',\n        path: 'external_id:{external_id}',\n      },\n      externalId,\n      dataOrOptions,\n      options,\n    );\n  }\n\n  /**\n   * Immediately deletes a user.\n   *\n   * @param externalId\n   * @param options - override client request options.\n   **/\n  deleteByExternalId(externalId: string, options?: RequestOptions): Promise<void> {\n    return this.request(\n      {\n        method: 'DELETE',\n        path: 'external_id:{external_id}',\n      },\n      externalId,\n      options,\n    );\n  }\n}\n","import axios, { AxiosError, AxiosResponse } from 'axios';\n\nimport { createHmac } from './lib/crypto';\nimport { getClientUserAgent, getUserAgent } from './lib/env';\nimport { createError } from './lib/error';\nimport { normalizeHeaders } from './lib/headers';\nimport { Logger, toCurl } from './lib/log';\nimport { compact, hasOwn, joinAnd, sleep, uuid4 } from './lib/utils';\nimport { createListener } from './listen';\nimport { isOptionsHash } from './options';\nimport { Imports } from './resources/imports';\nimport { NotificationPreferences } from './resources/notification-preferences';\nimport { Notifications } from './resources/notifications';\nimport { PushSubscriptions } from './resources/push-subscriptions';\nimport { Subscriptions } from './resources/subscriptions';\nimport { Users } from './resources/users';\nimport { ClientOptions, RequestArgs, RequestMethod, RequestOptions } from './types';\n\n// some environments, like vscode extensions, don't have the XMLHttpRequest object defined.\nif (typeof XMLHttpRequest !== 'function') {\n  axios.defaults.adapter = require('axios/lib/adapters/http');\n}\n\nexport const DEFAULT_OPTIONS: Partial<ClientOptions> = {\n  host: 'https://api.magicbell.com',\n  timeout: 30_000,\n  maxRetries: 3,\n  maxRetryDelay: 60,\n  telemetry: true,\n};\n\ntype Telemetry = { id: string; runtime: number; duration: number; status: number };\n\nexport class Client {\n  #userAgent: string;\n  #clientUserAgent: string;\n  #options: ClientOptions;\n  #logger = new Logger();\n  #features: Record<string, boolean> = {};\n  #lastRequest: Telemetry[] = [];\n  listen = createListener(this);\n\n  imports = new Imports(this);\n  notificationPreferences = new NotificationPreferences(this);\n  notifications = new Notifications(this);\n  pushSubscriptions = new PushSubscriptions(this);\n  subscriptions = new Subscriptions(this);\n  users = new Users(this);\n\n  constructor(options: ClientOptions) {\n    const missingOptions = ['apiKey'].filter((x) => !hasOwn(options, x));\n    if (missingOptions.length) {\n      throw new Error(\n        `You haven't provided all required options, please provide ${joinAnd(...missingOptions)} to Client(options)`,\n      );\n    }\n\n    if (!isOptionsHash(options)) {\n      throw new Error(`You have provided invalid options. Please check your client options.`);\n    }\n\n    this.#options = Object.assign({}, DEFAULT_OPTIONS, options);\n    this.#logger.active = Boolean(this.#options.debug);\n    this.#clientUserAgent = getClientUserAgent(options.appInfo);\n    this.#userAgent = getUserAgent(options.appInfo);\n    this.#features = options.features || {};\n  }\n\n  hasFlag(flag: string) {\n    return this.#features[flag] || false;\n  }\n\n  async request<TResponse = any>({ method, path, data, params }: RequestArgs, options?: RequestOptions) {\n    const requestOptions = { ...this.#options, ...options };\n\n    // compute headers out of the retry-loop, only append the telemetry later\n    const headers = this.#getHeaders(requestOptions, method);\n\n    const maxRetries = Math.max(0, requestOptions.maxRetries);\n    for (let attempt = 1; attempt <= maxRetries; attempt++) {\n      let response: AxiosResponse<TResponse, any>;\n      let error: AxiosError | null;\n      const startTime = Date.now();\n\n      this.#logger.debug(`${method} ${path}`);\n      await axios({\n        method,\n        url: path,\n        baseURL: requestOptions.host,\n        headers: {\n          ...headers,\n          ...normalizeHeaders({\n            'X-MAGICBELL-CLIENT-TELEMETRY': this.#getTelemetryHeader(),\n          }),\n        },\n        data,\n        // TODO: verify arrays are serialized in a way we support\n        params,\n        timeout: requestOptions.timeout,\n      })\n        .then((res) => {\n          response = res;\n        })\n        .catch((e) => {\n          const curl = toCurl({ method, baseURL: requestOptions.host, url: path, data, params, headers });\n          this.#logger.error(`${e.message}: ${curl}`);\n\n          error = e;\n          response = e.response;\n        });\n\n      this.#logLastRequest(response, { startTime });\n\n      if (this.#shouldRetry(response, attempt, maxRetries)) {\n        const retryAfter = Number(response.headers['retry-after']);\n        await sleep(this.#getSleepTimeInMS(attempt, retryAfter, requestOptions.maxRetryDelay));\n        continue;\n      }\n\n      if (error) {\n        throw createError({\n          name: error.name,\n          message: error.message,\n          type: error['type'],\n          status: response.status,\n          statusText: response.statusText,\n          ...(response?.data as any)?.errors?.[0],\n        });\n      }\n\n      return response.data;\n    }\n  }\n\n  #getHeaders(options: ClientOptions, method: RequestMethod) {\n    let userHmac = options.userHmac;\n    if (!userHmac && options.apiSecret && (options.userExternalId || options.userEmail)) {\n      userHmac = createHmac(options.apiSecret, options.userExternalId || options.userEmail);\n    }\n\n    const isBrowser = typeof document !== 'undefined';\n\n    return compact(\n      normalizeHeaders({\n        // can't set user-agent in the browser, see https://developer.mozilla.org/en-US/docs/Glossary/Forbidden_header_name\n        'User-Agent': isBrowser ? null : this.#userAgent,\n        'Idempotency-Key': options.idempotencyKey || this.#getDefaultIdempotencyKey(method, options.maxRetries),\n        'Accept-Version': 'v2',\n        'X-MAGICBELL-API-KEY': options.apiKey,\n        'X-MAGICBELL-API-SECRET': options.apiSecret,\n        'X-MAGICBELL-CLIENT-USER-AGENT': this.#clientUserAgent,\n        'X-MAGICBELL-USER-EMAIL': options.userEmail,\n        'X-MAGICBELL-USER-EXTERNAL-ID': options.userExternalId,\n        'X-MAGICBELL-USER-HMAC': userHmac,\n      }),\n      true,\n    );\n  }\n\n  #logLastRequest(response: AxiosResponse | undefined, { startTime }) {\n    // don't collect telemetry if the user opted out.\n    if (!this.#options.telemetry || !response?.status) return;\n\n    const headers = normalizeHeaders(response.headers);\n    this.#lastRequest.push({\n      id: headers['X-Request-Id'],\n      runtime: Number(headers['X-Runtime']),\n      duration: Date.now() - startTime,\n      status: response.status,\n    });\n  }\n\n  #getTelemetryHeader() {\n    const telemetry = this.#lastRequest.pop();\n    if (!telemetry) return null;\n    return JSON.stringify(telemetry);\n  }\n\n  #shouldRetry(response: AxiosResponse | undefined, attempt: number, maxRetries: number) {\n    // Do not retry if we are out of retries.\n    if (attempt >= maxRetries) {\n      return false;\n    }\n\n    if (!response) {\n      return true;\n    }\n\n    // Use the server's recommendation if it provides one\n    if (response.headers['should-retry']) {\n      return response.headers['should-retry'] === 'true';\n    }\n\n    if (response.status === 409 || response.status === 503) {\n      // Retry on conflict, rate limit, and availability errors.\n      return true;\n    }\n\n    // Retry on 5xx's, except POST's, which our idempotency framework would just replay as 500's again anyway.\n    if (response.status >= 500 && response.request.method !== 'POST') {\n      return true;\n    }\n\n    return false;\n  }\n\n  #getSleepTimeInMS(numRetries: number, retryAfter = null, maxDelay: number) {\n    const firstDelay = 0.5;\n\n    // Apply exponential backoff between firstDelay and maxRetryDelay\n    let sleepSeconds = Math.min(firstDelay * Math.pow(numRetries, 2), maxDelay);\n\n    // Apply some jitter by randomizing the value in the range of 75% - 100% of sleepSeconds.\n    sleepSeconds *= 0.75 * (1 + Math.random());\n\n    // But never sleep less than the base sleep seconds.\n    sleepSeconds = Math.min(Math.max(firstDelay, sleepSeconds), maxDelay);\n\n    // And never sleep less than the time the API asks us to wait, assuming it's a reasonable ask.\n    if (Number.isInteger(retryAfter) && retryAfter <= 60) {\n      sleepSeconds = Math.max(sleepSeconds, retryAfter);\n    }\n\n    return sleepSeconds * 1000;\n  }\n\n  #getDefaultIdempotencyKey(method: RequestMethod, maxRetries: number) {\n    if (method !== 'POST' || maxRetries === 0) return;\n    return `magicbell-retry-${uuid4()}`;\n  }\n}\n"],"names":["createHmac","secret","data","crypto","getEnvInfo","common","__spreadProps","__spreadValues","_a","getAppInfoAsString","appInfo","getUserAgent","env","getClientUserAgent","createError","rawError","field","AuthenticationError","InvalidRequestError","APIError","RateLimitError","IdempotencyError","NotFoundError","UserInputError","UnknownError","BaseError","raw","__publicField","normalizeHeaders","headers","normalized","header","normalizeHeader","exceptions","text","colors","Logger","message","mask","str","secrets","isSecret","key","toCurl","method","baseURL","url","value","hasOwn","obj","prop","isString","isBoolean","isArray","isStringArray","x","isNumber","isObject","compact","dropEmptyString","result","uuid4","c","r","sleep","ms","resolve","joinAnd","parts","last","joinUrlSegments","segments","ASYNC_ITERATOR_SYMBOL","hasMore","pageResult","autoPaginate","makeRequest","params","promiseCache","reverseIteration","i","request","getNextPage","page","iterate","dataKey","idx","asyncIteratorNext","memoizedPromise","reject","forEach","makeForEach","toArray","makeToArray","autoPaginationMethods","cb","ret","onDoneCallback","onItem","handleIteration","iterResult","item","shouldContinue","options","limit","items","createListener","client","args","eventSource","channels","lastEvent","configPromise","messages","pushMessage","p","connect","auth","token","axios","sseHost","EventSource","event","msg","err","listen","dispose","optionValidators","isOptionsHash","object","queryParamValidators","isForcedQueryParams","getUrl","path","$0","$1","extractUrlParams","param","getDataFromArgs","getOptionsFromArgs","arg","normalizeArgs","argsCopy","urlData","dataFromArgs","dataInQuery","isEmptyPayload","Resource","paged","tplPath","entity","response","flag","Imports","dataOrOptions","importId","NotificationPreferences","Notifications","notificationId","PushSubscriptions","deviceToken","Subscriptions","topic","Users","userId","userEmail","externalId","DEFAULT_OPTIONS","Client","__privateAdd","_getHeaders","_logLastRequest","_getTelemetryHeader","_shouldRetry","_getSleepTimeInMS","_getDefaultIdempotencyKey","_userAgent","_clientUserAgent","_options","_logger","_features","_lastRequest","missingOptions","__privateSet","__privateGet","requestOptions","__privateMethod","getHeaders_fn","maxRetries","attempt","error","startTime","getTelemetryHeader_fn","res","e","curl","logLastRequest_fn","shouldRetry_fn","retryAfter","getSleepTimeInMS_fn","_b","userHmac","getDefaultIdempotencyKey_fn","telemetry","numRetries","maxDelay","sleepSeconds"],"mappings":"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"}